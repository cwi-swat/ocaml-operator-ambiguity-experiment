(
   let
   (
      test
    (
     case
         (
      		  msg
      		(
      		 case
      		     (
      		  		  f
      		  		(
      		  		 case
      		  		     (
      		  		  		 arg
      		  		  		(
      		  		  		 case
      		  		  		     (
      		  		  		 	  r
      		  		  		      ifthenelse
      		  		  		      (
      		  		  		       if
      		  		  		       (
      		  		  		        <>
      		  		  		        (
      		  		  		            f
      		  		  		            (
      		  		  		                arg
      		  		  		            )
      		  		  		            r
      		  		  		        )
      		  		  		       )
      		  		  		       then
      		  		  		       (
      		  		  		        sequence
      		  		  		        (
      		  		  		          prerr_endline
      		  		  		          (
      		  		  		              msg
      		  		  		          )
      		  		  		        ;
      		  		  		          failwith
      		  		  		          (
      		  		  		              "Malaise"
      		  		  		          )
      		  		  		        )
      		  		  		       )
      		  		  		       else
      		  		  		       (
      		  		  		       )
      		  		  		      )
      		  		  		     )
      		  		  		)
      		  		     )
      		  		)
      		     )
      		)
         )
    )
   )
   type
   (  						
      t
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        A
        (
        )
        B
        (
        )
        C
        (
        )
        D
        (
        )
        E
        (
        )
        F
        (
        )
        )
   )
   let
   (
     f
    (
     case
         (
     	  x
          match
          x
          (
          case
          (
            pat_or
            (
             pat_or
             (
              A
              B
             )
             C
            )
            1
          ) 
            case
            (
             pat_or
             (
              D
              E
             )
             2
            )
            case
            (
             F
             3
            )
          )
         )
    )
   )
  sequence
  (
    test
    (
        "un"
        f
        C
        1
    )
  ;
    sequence
    (
      test
      (
          "un"
          f
          D
          2
      )
    ;
      sequence
      (
        test
        (
            "un"
            f
            F
            3
        )
      ;
        ()
      )
    )
  )
   let
   (
     g
    (
     case
         (
     	  x
          match
          x
          (
          case
          (
            1
            1
          ) 
            case
            (
             2
             2
            )
            case
            (
             3
             3
            )
            case
            (
             pat_or
             (
              4
              5
             )
             4
            )
            case
            (
             6
             5
            )
            case
            (
             pat_or
             (
              7
              8
             )
             6
            )
            case
            (
             9
             7
            )
            case
            (
             _
             assert false
            )
          )
         )
    )
   )
  sequence
  (
    test
    (
        "deux"
        g
        5
        4
    )
  ;
    sequence
    (
      test
      (
          "deux"
          g
          6
          5
      )
    ;
      sequence
      (
        test
        (
            "deux"
            g
            9
            7
        )
      ;
        ()
      )
    )
  )
   let
   (
     g
    (
     case
         (
     	  x
          match
          x
          (
          case
          (
            1
            1
          ) 
            case
            (
             2
             2
            )
            case
            (
             3
             3
            )
            case
            (
             pat_or
             (
              4
              5
             )
             4
            )
            case
            (
             6
             5
            )
            case
            (
             pat_or
             (
              7
              8
             )
             6
            )
            case
            (
             9
             7
            )
            case
            (
             _
             8
            )
          )
         )
    )
   )
  test
  (
      "trois"
      g
      10
      8
  )
   let
   (
     g
    (
     case
         (
     	  x
          match
          x
          (
          case
          (
            1
            1
          ) 
            case
            (
             2
             2
            )
            case
            (
             3
             3
            )
            case
            (
             pat_or
             (
              4
              5
             )
             4
            )
            case
            (
             6
             5
            )
            case
            (
             pat_or
             (
              pat_or
              (
               4
               5
              )
              7
             )
             100
            )
            case
            (
             pat_or
             (
              7
              8
             )
             6
            )
            case
            (
             9
             7
            )
            case
            (
             _
             8
            )
          )
         )
    )
   )
  sequence
  (
    test
    (
        "quatre"
        g
        4
        4
    )
  ;
    sequence
    (
      test
      (
          "quatre"
          g
          7
          100
      )
    ;
      ()
    )
  )
   let
   (
     h
    (
     case
         (
     	  x
          match
          x
          (
          case
          (
            (
             1
            	1
            )
            1
          ) 
            case
            (
             (
              pat_or
              (
               2
               3
              )
             	1
             )
             2
            )
            case
            (
             (
              2
             	pat_or
             	(
             	 2
             	 3
             	)
             )
             3
            )
            case
            (
             (
              4
             	4
             )
             5
            )
            case
            (
             _
             100
            )
          )
         )
    )
   )
  sequence
  (
    test
    (
        "cinq"
        h
        (
         2
        	2
        )
        3
    )
  ;
    sequence
    (
      test
      (
          "cinq"
          h
          (
           2
          	1
          )
          2
      )
    ;
      sequence
      (
        test
        (
            "cinq"
            h
            (
             2
            	4
            )
            100
        )
      ;
        ()
      )
    )
  )
   let
   (
     hh
    (
     case
         (
     	  x
          match
          x
          (
          case
          (
            (
             1
            	1
            )
            1
          ) 
            case
            (
             (
              2
             	1
             )
             2
            )
            case
            (
             (
              pat_or
              (
               2
               3
              )
             	pat_or
             	(
             	 pat_or
             	 (
             	  pat_or
             	  (
             	   1
             	   2
             	  )
             	  3
             	 )
             	 4
             	)
             )
             3
            )
            case
            (
             (
              2
             	5
             )
             4
            )
            case
            (
             (
              4
             	4
             )
             5
            )
            case
            (
             _
             100
            )
          )
         )
    )
   )
   let
   (
     hhh
    (
     case
         (
     	  x
          match
          x
          (
          case
          (
            (
             1
            	1
            )
            1
          ) 
            case
            (
             (
              pat_or
              (
               2
               3
              )
             	1
             )
             2
            )
            case
            (
             (
              2
             	2
             )
             3
            )
            case
            (
             _
             100
            )
          )
         )
    )
   )
   let
   (
     h
    (
     case
         (
     	  x
          match
          x
          (
          case
          (
            (
             1
            	1
            )
            1
          ) 
            case
            (
             (
              3
             	1
             )
             2
            )
            case
            (
             (
              2
             	pat_or
             	(
             	 2
             	 3
             	)
             )
             3
            )
            case
            (
             (
              4
             	4
             )
             5
            )
            case
            (
             _
             100
            )
          )
         )
    )
   )
   let
   (
     h
    (
     case
         (
     	  x
          match
          x
          (
          case
          (
            1
            1
          ) 
            case
            (
             pat_or
             (
              2
              3
             )
             2
            )
            case
            (
             4
             4
            )
            case
            (
             5
             5
            )
            case
            (
             pat_or
             (
              6
              7
             )
             6
            )
            case
            (
             8
             8
            )
            case
            (
             _
             100
            )
          )
         )
    )
   )
   let
   (
     f
    (
     case
         (
     	  x
          match
          x
          (
          case
          (
            pat_or
            (
             (
              pat_or
              (
               1
               2
              )
             	pat_or
             	(
             	 3
             	 4
             	)
             )
             (
              pat_or
              (
               3
               4
              )
             	pat_or
             	(
             	 1
             	 2
             	)
             )
            )
            1
          ) 
            case
            (
             (
              3
             	pat_or
             	(
             	 5
             	 6
             	)
             )
             2
            )
            case
            (
             _
             3
            )
          )
         )
    )
   )
  sequence
  (
    test
    (
        "six"
        f
        (
         1
        	3
        )
        1
    )
  ;
    sequence
    (
      test
      (
          "six"
          f
          (
           3
          	2
          )
          1
      )
    ;
      sequence
      (
        test
        (
            "six"
            f
            (
             3
            	5
            )
            2
        )
      ;
        sequence
        (
          test
          (
              "six"
              f
              (
               3
              	7
              )
              3
          )
        ;
          ()
        )
      )
    )
  )
   type
   (  						
      tt
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
         a
         poly
          list
          (
            bool
            (
            )
          )
         b
         poly
         bool
         (
         )
        )
   )
   let
   (
     f
     (
      case
      (
        patternRec 
        (
            a
            pat_or
            (
             []
             ::
             (
               true
               []
             )
            )
        )
        1
      ) 
        case
        (
         pat_or
         (
          patternRec 
          (
              a
              ::
              (
                  false
                  _
              )
          )
          patternRec 
          (
              b
              pat_or
              (
               true
               false
              )
          )
         )
         2
        )
     )
   )
  sequence
  (
    test
    (
        "sept"
        f
        record
        (
         a
         []
           b
           true
        )
        1
    )
  ;
    sequence
    (
      test
      (
          "sept"
          f
          record
          (
           a
           ::
            (
            true
            []
            ) 
             b
             false
          )
          1
      )
    ;
      sequence
      (
        test
        (
            "sept"
            f
            record
            (
             a
             ::
              (
              false
              ::
              (
              true
              []
              ) 
              ) 
               b
               true
            )
            2
        )
      ;
        sequence
        (
          test
          (
              "sept"
              f
              record
              (
               a
               ::
                (
                false
                []
                ) 
                 b
                 false
              )
              2
          )
        ;
          ()
        )
      )
    )
  )
   let
   (
     f
     (
      case
      (
        (
         pat_or
         (
          []
          ::
          (
            true
            []
          )
         )
        	_
        )
        1
      ) 
        case
        (
         pat_or
         (
          (
           ::
           (
               false
               _
           )
          	_
          )
          (
           _
          	pat_or
          	(
          	 true
          	 false
          	)
          )
         )
         2
        )
     )
   )
  sequence
  (
    test
    (
        "huit"
        f
        (
         []
        	true
        )
        1
    )
  ;
    sequence
    (
      test
      (
          "huit"
          f
          (
           ::
            (
            true
            []
            ) 
          	false
          )
          1
      )
    ;
      sequence
      (
        test
        (
            "huit"
            f
            (
             ::
              (
              false
              ::
              (
              true
              []
              ) 
              ) 
            	true
            )
            2
        )
      ;
        sequence
        (
          test
          (
              "huit"
              f
              (
               ::
                (
                false
                []
                ) 
              	false
              )
              2
          )
        ;
          ()
        )
      )
    )
  )
   let
   (
     split_cases
     (
      case
      (
        alias x
        (
          pat_or
          (
           Nil
           Cons
           _
          )
        )
        A
           x
      ) 
        case
        (
         alias x
         (
           Snoc
           _
         )
         B
            x
        )
     )
   )
  sequence
  (
    test
    (
        "oubli"
        split_cases
        Nil
        A
           Nil
    )
  ;
    sequence
    (
      test
      (
          "oubli"
          split_cases
          Cons
             1
          A
             Cons
                1
      )
    ;
      sequence
      (
        test
        (
            "oubli"
            split_cases
            Snoc
               1
            B
               Snoc
                  1
        )
      ;
        ()
      )
    )
  )
   type
   (  						
      t1
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        A
        (
         int
         (
         )
        )
        B
        (
         int
         (
         )
        )
        )
   )
   let
   (
     f1
     (
      case
      (
        pat_or
        (
         A
         x
         B
         x
        )
        x
      ) 
     )
   )
  sequence
  (
    test
    (
        "neuf"
        f1
        A
           1
        1
    )
  ;
    test
    (
        "neuf"
        f1
        B
           1
        1
    )
  )
   type
   (  						
      coucou
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        A
        (
         int
         (
         )
        )
        B
        (
         int
         (
         )
         int
         (
         )
        )
        C
        (
        )
        )
   )
   let
   (
     g
     (
      case
      (
        pat_or
        (
         A
         x
         B
         (
          _
         	x
         )
        )
        x
      ) 
        case
        (
         C
         0
        )
     )
   )
  sequence
  (
    test
    (
        "dix"
        g
        A
           1
        1
    )
  ;
    test
    (
        "dix"
        g
        B
           (
            1
           	2
           )
        2
    )
  )
   let
   (
     h
     (
      case
      (
        pat_or
        (
         pat_or
         (
          ::
          (
            x
            []
          )
          ::
          (
            1
            ::
            (
              x
              []
            )
          )
         )
         ::
         (
           1
           ::
           (
             2
             ::
             (
               x
               []
             )
           )
         )
        )
        x
      ) 
        case
        (
         _
         0
        )
     )
   )
  sequence
  (
    test
    (
        "encore"
        h
        ::
         (
         1
         []
         ) 
        1
    )
  ;
    sequence
    (
      test
      (
          "encore"
          h
          ::
           (
           1
           ::
           (
           2
           []
           ) 
           ) 
          2
      )
    ;
      sequence
      (
        test
        (
            "encore"
            h
            ::
             (
             1
             ::
             (
             2
             ::
             (
             3
             []
             ) 
             ) 
             ) 
            3
        )
      ;
        sequence
        (
          test
          (
              "encore"
              h
              ::
               (
               0
               ::
               (
               0
               []
               ) 
               ) 
              0
          )
        ;
          ()
        )
      )
    )
  )
   let
   (
     f
     (
      case
      (
        pat_or
        (
         (
          x
         	alias y
         	(
         	  0
         	)
         )
         (
          y
         	x
         )
        )
        -
        (
            y
            x
        )
      ) 
     )
   )
  sequence
  (
    test
    (
        "foo1"
        f
        (
         1
        	0
        )
        -1
    )
  ;
    test
    (
        "foo1"
        f
        (
         1
        	2
        )
        -1
    )
  )
   let
   (
     f
     (
      case
      (
        pat_or
        (
         pat_or
         (
          alias x
          (
            pat_or
            (
             []
             ::
             (
               _
               []
             )
            )
          )
          ::
          (
              _
              alias x
              (
                []
              )
          )
         )
         ::
         (
             _
             ::
             (
                 _
                 x
             )
         )
        )
        x
      ) 
     )
   )
  sequence
  (
    test
    (
        "zob"
        f
        []
        []
    )
  ;
    sequence
    (
      test
      (
          "zob"
          f
          ::
           (
           1
           []
           ) 
          ::
           (
           1
           []
           ) 
      )
    ;
      test
      (
          "zob"
          f
          ::
           (
           1
           ::
           (
           2
           ::
           (
           3
           []
           ) 
           ) 
           ) 
          ::
           (
           3
           []
           ) 
      )
    )
  )
   type
   (  						
      zob
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        A
        (
        )
        B
        (
        )
        C
        (
        )
        D
        (
         zob
         (
         )
         int
         (
         )
        )
        E
        (
         zob
         (
         )
         zob
         (
         )
        )
        )
   )
   let
   (
     f
     (
      case
      (
        pat_or
        (
         pat_or
         (
          A
          B
         )
         C
        )
        A
      ) 
        case
        (
         D
         (
          x
         	i
         )
         D
            (
             f
             (
                 x
             )
            	i
            )
        )
        case
        (
         E
         (
          x
         	_
         )
         D
            (
             f
             (
                 x
             )
            	0
            )
        )
     )
   )
  sequence
  (
    test
    (
        "fin"
        f
        B
        A
    )
  ;
    sequence
    (
      test
      (
          "fin"
          f
          D
             (
              C
             	1
             )
          D
             (
              A
             	1
             )
      )
    ;
      sequence
      (
        test
        (
            "fin"
            f
            E
               (
                C
               	A
               )
            D
               (
                A
               	0
               )
        )
      ;
        ()
      )
    )
  )
   type
   (  						
      length
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        Char
        (
         int
         (
         )
        )
        Pixel
        (
         int
         (
         )
        )
        Percent
        (
         int
         (
         )
        )
        No
        (
         string
         (
         )
        )
        Default
        (
        )
        )
   )
   let
   (
     length
     (
      case
      (
        Char
        n
        n
      ) 
        case
        (
         Pixel
         n
         n
        )
        case
        (
         _
         0
        )
     )
   )
  sequence
  (
    test
    (
        "length"
        length
        Char
           10
        10
    )
  ;
    sequence
    (
      test
      (
          "length"
          length
          Pixel
             20
          20
      )
    ;
      sequence
      (
        test
        (
            "length"
            length
            Default
            0
        )
      ;
        sequence
        (
          test
          (
              "length"
              length
              Percent
                 100
              0
          )
        ;
          ()
        )
      )
    )
  )
   let
   (
     length2
     (
      case
      (
        Char
        n
        n
      ) 
        case
        (
         Percent
         n
         n
        )
        case
        (
         _
         0
        )
     )
   )
  sequence
  (
    test
    (
        "length2"
        length2
        Char
           10
        10
    )
  ;
    sequence
    (
      test
      (
          "length2"
          length2
          Pixel
             20
          0
      )
    ;
      sequence
      (
        test
        (
            "length2"
            length2
            Default
            0
        )
      ;
        sequence
        (
          test
          (
              "length2"
              length2
              Percent
                 100
              100
          )
        ;
          ()
        )
      )
    )
  )
   let
   (
     length3
     (
      case
      (
        pat_or
        (
         Char
         _
         No
         _
        )
        true
      ) 
        case
        (
         _
         false
        )
     )
   )
  sequence
  (
    test
    (
        "length3"
        length3
        Char
           10
        true
    )
  ;
    sequence
    (
      test
      (
          "length3"
          length3
          No
             ""
          true
      )
    ;
      sequence
      (
        test
        (
            "length3"
            length3
            Pixel
               20
            false
        )
      ;
        sequence
        (
          test
          (
              "length3"
              length3
              Default
              false
          )
        ;
          sequence
          (
            test
            (
                "length3"
                length3
                Percent
                   100
                false
            )
          ;
            ()
          )
        )
      )
    )
  )
   type
   (  						
      hevea
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        A
        (
        )
        B
        (
        )
        C
        (
        )
        )
   )
   let
   (
     h
    (
     case
         (
     	  x
          match
          x
          (
          case
          (
            A
            1
          ) 
            case
            (
             pat_or
             (
              B
              C
             )
             2
            )
          )
         )
    )
   )
  sequence
  (
    test
    (
        "hevea"
        h
        A
        1
    )
  ;
    sequence
    (
      test
      (
          "hevea"
          h
          B
          2
      )
    ;
      sequence
      (
        test
        (
            "hevea"
            h
            B
            2
        )
      ;
        ()
      )
    )
  )
   type
   (  						
      lambda
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        Lvar
        (
         int
         (
         )
        )
        Lconst
        (
         int
         (
         )
        )
        Lapply
        (
         lambda
         (
         )
          list
          (
            lambda
            (
            )
          )
        )
        Lfunction
        (
         bool
         (
         )
          list
          (
            int
            (
            )
          )
         lambda
         (
         )
        )
        Llet
        (
         bool
         (
         )
         int
         (
         )
         lambda
         (
         )
         lambda
         (
         )
        )
        Lletrec
        (
          list
          (
            tuple
            (
             int
             (
             )
              lambda
              (
              )
            )
          )
         lambda
         (
         )
        )
        Lprim
        (
         string
         (
         )
          list
          (
            lambda
            (
            )
          )
        )
        Lswitch
        (
         lambda
         (
         )
         lambda_switch
         (
         )
        )
        Lstaticfail
        (
        )
        Lcatch
        (
         lambda
         (
         )
         lambda
         (
         )
        )
        Lstaticraise
        (
         int
         (
         )
          list
          (
            lambda
            (
            )
          )
        )
        Lstaticcatch
        (
         lambda
         (
         )
         tuple
         (
          int
          (
          )
            list
            (
              int
              (
              )
            )
         )
         lambda
         (
         )
        )
        Ltrywith
        (
         lambda
         (
         )
         int
         (
         )
         lambda
         (
         )
        )
        Lifthenelse
        (
         lambda
         (
         )
         lambda
         (
         )
         lambda
         (
         )
        )
        Lsequence
        (
         lambda
         (
         )
         lambda
         (
         )
        )
        Lwhile
        (
         lambda
         (
         )
         lambda
         (
         )
        )
        Lfor
        (
         int
         (
         )
         lambda
         (
         )
         lambda
         (
         )
         bool
         (
         )
         lambda
         (
         )
        )
        Lassign
        (
         int
         (
         )
         lambda
         (
         )
        )
        Lsend
        (
         lambda
         (
         )
         lambda
         (
         )
          list
          (
            lambda
            (
            )
          )
        )
        Levent
        (
         lambda
         (
         )
         lambda_event
         (
         )
        )
        Lifused
        (
         int
         (
         )
         lambda
         (
         )
        )
        )
      lambda_switch
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
         sw_numconsts
         poly
         int
         (
         )
         sw_consts
         poly
          list
          (
            tuple
            (
             int
             (
             )
              lambda
              (
              )
            )
          )
         sw_numblocks
         poly
         int
         (
         )
         sw_blocks
         poly
          list
          (
            tuple
            (
             int
             (
             )
              lambda
              (
              )
            )
          )
         sw_checked
         poly
         bool
         (
         )
         sw_nofail
         poly
         bool
         (
         )
        )
      lambda_event
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
         lev_loc
         poly
         int
         (
         )
         lev_kind
         poly
         bool
         (
         )
         lev_repr
         poly
          option
          (
             ref
             (
               int
               (
               )
             )
          )
         lev_env
         poly
          list
          (
            int
            (
            )
          )
        )
   )
   let
   (
      approx_present
    (
     case
         (
      		 v
      		(
      		 case
      		     (
      		 	  l
      		      true
      		     )
      		)
         )
    )
   )
   let
   (
      lower_bind
    (
     case
         (
      		  v
      		(
      		 case
      		     (
      		  		 arg
      		  		(
      		  		 case
      		  		     (
      		  		 	  lam
      		  		      match
      		  		      lam
      		  		      (
      		  		      case
      		  		      (
      		  		        Lifthenelse
      		  		        (
      		  		         cond
      		  		        	ifso
      		  		        	ifnot
      		  		        )
      		  		        1
      		  		      ) 
      		  		        case
      		  		        (
      		  		         Lswitch
      		  		         (
      		  		          ls
      		  		         	alias _sw
      		  		         	(
      		  		         	  patternRec 
      		  		         	  (
      		  		         	      sw_consts
      		  		         	      ::
      		  		         	      (
      		  		         	        (
      		  		         	         i
      		  		         	        	act
      		  		         	        )
      		  		         	        []
      		  		         	      )
      		  		         	      <"field_name"("sw_blocks")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"patternConstant"("emptyBrackets"()[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
      		  		         	  )
      		  		         	)
      		  		         )
      		  		         when
      		  		         not
      		  		         (
      		  		             approx_present
      		  		             (
      		  		                 v
      		  		                 ls
      		  		             )
      		  		         )
      		  		         2
      		  		        )
      		  		        case
      		  		        (
      		  		         Lswitch
      		  		         (
      		  		          ls
      		  		         	alias _sw
      		  		         	(
      		  		         	  patternRec 
      		  		         	  (
      		  		         	      sw_consts
      		  		         	      []
      		  		         	      <"field_name"("sw_blocks")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"patternTuple"(["patterns"("patternValueName"("i")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],["patternValueName"("act")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],[])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
      		  		         	  )
      		  		         	)
      		  		         )
      		  		         when
      		  		         not
      		  		         (
      		  		             approx_present
      		  		             (
      		  		                 v
      		  		                 ls
      		  		             )
      		  		         )
      		  		         3
      		  		        )
      		  		        case
      		  		        (
      		  		         Llet
      		  		         (
      		  		          true
      		  		         	vv
      		  		         	lv
      		  		         	l
      		  		         )
      		  		         4
      		  		        )
      		  		        case
      		  		        (
      		  		         _
      		  		         5
      		  		        )
      		  		      )
      		  		     )
      		  		)
      		     )
      		)
         )
    )
   )
  sequence
  (
    test
    (
        "lower_bind"
        lower_bind
        (
            0
            0
        )
        Llet
           (
            true
           	0
           	Lvar
           	   1
           	Lvar
           	   2
           )
        4
    )
  ;
    sequence
    (
      test
      (
          "lower_bind"
          lower_bind
          (
              0
              0
          )
          Lvar
             0
          5
      )
    ;
      test
      (
          "lower_bind"
          lower_bind
          (
              0
              0
          )
          Lifthenelse
             (
              Lvar
                 0
             	Lvar
             	   1
             	Lvar
             	   2
             )
          1
      )
    )
  )
   type
   (  						
      field_kind
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        Fvar
        (
          ref
          (
             option
             (
               field_kind
               (
               )
             )
          )
        )
        Fpresent
        (
        )
        Fabsent
        (
        )
        )
   )
   let
   (
     unify_kind
    (
     case
         (
     	  (
     	   k1
     	  	k2
     	  )
          match
          (
           k1
          	k2
          )
          (
          case
          (
            (
             Fvar
             r
            	pat_or
            	(
            	 Fvar
            	 _
            	 Fpresent
            	)
            )
            1
          ) 
            case
            (
             (
              Fpresent
             	Fvar
             	r
             )
             2
            )
            case
            (
             (
              Fpresent
             	Fpresent
             )
             3
            )
            case
            (
             _
             4
            )
          )
         )
    )
   )
   let
   (
     r
     ref
     (
         Some
            Fpresent
     ) 
   )
  sequence
  (
    test
    (
        "unify"
        unify_kind
        (
         Fvar
            r
        	Fpresent
        )
        1
    )
  ;
    sequence
    (
      test
      (
          "unify"
          unify_kind
          (
           Fvar
              r
          	Fvar
          	   r
          )
          1
      )
    ;
      sequence
      (
        test
        (
            "unify"
            unify_kind
            (
             Fvar
                r
            	Fabsent
            )
            4
        )
      ;
        sequence
        (
          test
          (
              "unify"
              unify_kind
              (
               Fpresent
              	Fvar
              	   r
              )
              2
          )
        ;
          sequence
          (
            test
            (
                "unify"
                unify_kind
                (
                 Fpresent
                	Fpresent
                )
                3
            )
          ;
            sequence
            (
              test
              (
                  "unify"
                  unify_kind
                  (
                   Fabsent
                  	Fpresent
                  )
                  4
              )
            ;
              ()
            )
          )
        )
      )
    )
  )
   type
   (  						
      youyou
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        A
        (
        )
        B
        (
        )
        C
        (
        )
        D
        (
         youyou
         (
         )
        )
        )
   )
   let
   (
     foo
    (
     case
         (
     	  (
     	   k1
     	  	k2
     	  )
          match
          (
           k1
          	k2
          )
          (
          case
          (
            (
             D
             _
            	pat_or
            	(
            	 A
            	 D
            	 _
            	)
            )
            1
          ) 
            case
            (
             (
              pat_or
              (
               A
               B
              )
             	D
             	_
             )
             2
            )
            case
            (
             (
              C
             	_
             )
             3
            )
            case
            (
             (
              _
             	pat_or
             	(
             	 pat_or
             	 (
             	  A
             	  B
             	 )
             	 C
             	)
             )
             4
            )
          )
         )
    )
   )
  sequence
  (
    test
    (
        "foo2"
        foo
        (
         D
            A
        	A
        )
        1
    )
  ;
    sequence
    (
      test
      (
          "foo2"
          foo
          (
           D
              A
          	B
          )
          4
      )
    ;
      sequence
      (
        test
        (
            "foo2"
            foo
            (
             A
            	A
            )
            4
        )
      ;
        ()
      )
    )
  )
   type
   (  						
      yaya
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        A
        (
        )
        B
        (
        )
        )
   )
   let
   (
     yaya
     (
      case
      (
        (
         A
        	_
        	_
        )
        1
      ) 
        case
        (
         (
          _
         	A
         	_
         )
         2
        )
        case
        (
         (
          B
         	B
         	_
         )
         3
        )
        case
        (
         (
          A
         	_
         	pat_or
         	(
         	 100
         	 103
         	)
         )
         5
        )
     )
   )
  sequence
  (
    test
    (
        "yaya"
        yaya
        (
         A
        	A
        	0
        )
        1
    )
  ;
    sequence
    (
      test
      (
          "yaya"
          yaya
          (
           B
          	A
          	0
          )
          2
      )
    ;
      sequence
      (
        test
        (
            "yaya"
            yaya
            (
             B
            	B
            	100
            )
            3
        )
      ;
        ()
      )
    )
  )
   type
   (  						
      autre
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        C
        (
        )
        D
        (
        )
        E
        (
         autre
         (
         )
        )
        F
        (
         autre
         (
         )
         autre
         (
         )
        )
        H
        (
         autre
         (
         )
        )
        I
        (
        )
        J
        (
        )
        K
        (
         string
         (
         )
        )
        )
   )
   let
   (
     autre
     (
      case
      (
        (
         C
        	_
        	_
        )
        1
      ) 
        case
        (
         (
          _
         	C
         	_
         )
         2
        )
        case
        (
         (
          D
         	D
         	_
         )
         3
        )
        case
        (
         (
          pat_or
          (
           pat_or
           (
            pat_or
            (
             D
             F
             (
              _
             	_
             )
            )
            H
            _
           )
           K
           _
          )
         	_
         	_
         )
         4
        )
        case
        (
         (
          _
         	pat_or
         	(
         	 pat_or
         	 (
         	  pat_or
         	  (
         	   pat_or
         	   (
         	    pat_or
         	    (
         	     D
         	     I
         	    )
         	    E
         	    _
         	   )
         	   F
         	   (
         	    _
         	   	_
         	   )
         	  )
         	  H
         	  _
         	 )
         	 K
         	 _
         	)
         	_
         )
         8
        )
        case
        (
         pat_or
         (
          (
           J
          	J
          	pat_or
          	(
          	 pat_or
          	 (
          	  alias x
          	  (
          	    pat_or
          	    (
          	     C
          	     D
          	    )
          	  )
          	  E
          	  x
          	 )
          	 F
          	 (
          	  _
          	 	x
          	 )
          	)
          )
          (
           J
          	_
          	alias x
          	(
          	  pat_or
          	  (
          	   C
          	   J
          	  )
          	)
          )
         )
         autre
         (
             (
              x
             	x
             	x
             )
         )
        )
        case
        (
         (
          J
         	J
         	pat_or
         	(
         	 pat_or
         	 (
         	  I
         	  H
         	  _
         	 )
         	 K
         	 _
         	)
         )
         9
        )
        case
        (
         (
          I
         	_
         	_
         )
         6
        )
        case
        (
         (
          E
          _
         	_
         	_
         )
         7
        )
     )
   )
  sequence
  (
    test
    (
        "autre"
        autre
        (
         J
        	J
        	F
        	   (
        	    D
        	   	D
        	   )
        )
        3
    )
  ;
    sequence
    (
      test
      (
          "autre"
          autre
          (
           J
          	J
          	D
          )
          3
      )
    ;
      sequence
      (
        test
        (
            "autre"
            autre
            (
             J
            	J
            	I
            )
            9
        )
      ;
        sequence
        (
          test
          (
              "autre"
              autre
              (
               H
                  I
              	I
              	I
              )
              4
          )
        ;
          sequence
          (
            test
            (
                "autre"
                autre
                (
                 J
                	J
                	H
                	   I
                )
                9
            )
          ;
            ()
          )
        )
      )
    )
  )
   type
   (  						
      youpi
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        YA
        (
        )
        YB
        (
        )
        YC
        (
        )
        )
      hola
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        X
        (
        )
        Y
        (
        )
        Z
        (
        )
        T
        (
         hola
         (
         )
        )
        U
        (
         hola
         (
         )
        )
        V
        (
         hola
         (
         )
        )
        )
   )
   let
   (
     xyz
     (
      case
      (
        (
         YA
        	_
        	_
        )
        1
      ) 
        case
        (
         (
          _
         	YA
         	_
         )
         2
        )
        case
        (
         (
          YB
         	YB
         	_
         )
         3
        )
        case
        (
         (
          pat_or
          (
           YB
           YC
          )
         	pat_or
         	(
         	 YB
         	 YC
         	)
         	pat_or
         	(
         	 pat_or
         	 (
         	  pat_or
         	  (
         	   pat_or
         	   (
         	    X
         	    Y
         	   )
         	   Z
         	  )
         	  V
         	  _
         	 )
         	 T
         	 _
         	)
         )
         6
        )
        case
        (
         (
          _
         	_
         	pat_or
         	(
         	 X
         	 U
         	 _
         	)
         )
         8
        )
        case
        (
         (
          _
         	_
         	Y
         )
         5
        )
     )
   )
  sequence
  (
    test
    (
        "xyz"
        xyz
        (
         YC
        	YC
        	X
        )
        6
    )
  ;
    sequence
    (
      test
      (
          "xyz"
          xyz
          (
           YC
          	YB
          	U
          	   X
          )
          8
      )
    ;
      sequence
      (
        test
        (
            "xyz"
            xyz
            (
             YB
            	YC
            	X
            )
            6
        )
      ;
        ()
      )
    )
  )
   let
   (
     eq
    (
     case
         (
     	  (
     	   x
     	  	y
     	  )
          =
          (
              x
              y
          )
         )
    )
   )
  sequence
  (
    test
    (
        "eq"
        eq
        (
         "coucou"
        	"coucou"
        )
        true
    )
  ;
    ()
  )
   let
   (
     is_none
     (
      case
      (
        None
        true
      ) 
        case
        (
         _
         false
        )
     )
   )
   let
   (
     garde
    (
     case
         (
     	  x
          match
          x
          (
          case
          (
            (
             Some
             _
            	_
            )
            when
            is_none
            (
                snd
                (
                    x
                )
            )
            1
          ) 
            case
            (
             (
              Some
              (
               pc
              	_
              )
             	Some
             	pc'
             )
             when
             =
             (
                 pc
                 pc'
             )
             2
            )
            case
            (
             _
             3
            )
          )
         )
    )
   )
  sequence
  (
    test
    (
        "garde"
        garde
        (
         Some
            (
             1
            	1
            )
        	None
        )
        1
    )
  ;
    sequence
    (
      test
      (
          "garde"
          garde
          (
           Some
              (
               1
              	1
              )
          	Some
          	   1
          )
          2
      )
    ;
      sequence
      (
        test
        (
            "garde"
            garde
            (
             Some
                (
                 2
                	1
                )
            	Some
            	   1
            )
            3
        )
      ;
        ()
      )
    )
  )
   let
   (
     orstring
     (
      case
      (
        pat_or
        (
         pat_or
         (
          "A"
          "B"
         )
         "C"
        )
        2
      ) 
        case
        (
         "D"
         3
        )
        case
        (
         _
         4
        )
     )
   )
  sequence
  (
    test
    (
        "orstring"
        orstring
        "A"
        2
    )
  ;
    sequence
    (
      test
      (
          "orstring"
          orstring
          "B"
          2
      )
    ;
      sequence
      (
        test
        (
            "orstring"
            orstring
            "C"
            2
        )
      ;
        sequence
        (
          test
          (
              "orstring"
              orstring
              "D"
              3
          )
        ;
          sequence
          (
            test
            (
                "orstring"
                orstring
                "E"
                4
            )
          ;
            ()
          )
        )
      )
    )
  )
   type
   (  						
      var_t
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        <[],[<"Variant",[<[],[<"Some",["typexprConstr2"("typeConstr"([],"string")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>,<"None",[]>,<"Foo",[]>]>]>]>
   )
   let
   (
     crash
    (
     case
         (
     	  pat
     	  var_t
     	  (
     	  )
          match
          pat
          (
          case
          (
            Variant
            Some
            tag
            tag
          ) 
            case
            (
             Variant
             None
             "none"
            )
            case
            (
             _
             "foo"
            )
          )
         )
    )
   )
  sequence
  (
    test
    (
        "crash"
        crash
        Variant
           None
        "none"
    )
  ;
    sequence
    (
      test
      (
          "crash"
          crash
          Variant
             Some
                "coucou"
          "coucou"
      )
    ;
      sequence
      (
        test
        (
            "crash"
            crash
            Variant
               Foo
            "foo"
        )
      ;
        ()
      )
    )
  )
   let
   (
     flatgarde
    (
     case
         (
     	  c
          let
          (
           (
             (
              x
             	y
             )
             c 
           )
          in
            match
            (
             x
            	y
            )
            (
            case
            (
              pat_or
              (
               (
                1
               	2
               )
               (
                2
               	3
               )
              )
              when
              =
              (
                  y
                  2
              )
              1
            ) 
              case
              (
               pat_or
               (
                (
                 1
                	_
                )
                (
                 _
                	3
                )
               )
               2
              )
              case
              (
               _
               3
              )
            )
          )
         )
    )
   )
  sequence
  (
    test
    (
        "flatgarde"
        flatgarde
        (
         1
        	2
        )
        1
    )
  ;
    sequence
    (
      test
      (
          "flatgarde"
          flatgarde
          (
           1
          	3
          )
          2
      )
    ;
      sequence
      (
        test
        (
            "flatgarde"
            flatgarde
            (
             2
            	3
            )
            2
        )
      ;
        sequence
        (
          test
          (
              "flatgarde"
              flatgarde
              (
               2
              	4
              )
              3
          )
        ;
          ()
        )
      )
    )
  )
   type
   (  						
      f
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        ABSENT
        (
        )
        FILE
        (
        )
        SYMLINK
        (
        )
        DIRECTORY
        (
        )
        )
   )
   type
   (  						
      r
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        Unchanged
        (
        )
        Deleted
        (
        )
        Modified
        (
        )
        PropsChanged
        (
        )
        Created
        (
        )
        )
   )
   let
   (
     replicaContent2shortString
    (
     case
         (
     	  rc
          let
          (
           (
             (
              typ
             	status
             )
             rc 
           )
          in
            match
            (
             typ
            	status
            )
            (
            case
            (
              (
               _
              	Unchanged
              )
              "        "
            ) 
              case
              (
               (
                ABSENT
               	Deleted
               )
               "deleted "
              )
              case
              (
               (
                FILE
               	Created
               )
               "new file"
              )
              case
              (
               (
                FILE
               	Modified
               )
               "changed "
              )
              case
              (
               (
                FILE
               	PropsChanged
               )
               "props   "
              )
              case
              (
               (
                SYMLINK
               	Created
               )
               "new link"
              )
              case
              (
               (
                SYMLINK
               	Modified
               )
               "chgd lnk"
              )
              case
              (
               (
                DIRECTORY
               	Created
               )
               "new dir "
              )
              case
              (
               (
                DIRECTORY
               	Modified
               )
               "chgd dir"
              )
              case
              (
               (
                DIRECTORY
               	PropsChanged
               )
               "props   "
              )
              case
              (
               pat_or
               (
                pat_or
                (
                 (
                  ABSENT
                 	pat_or
                 	(
                 	 pat_or
                 	 (
                 	  Created
                 	  Modified
                 	 )
                 	 PropsChanged
                 	)
                 )
                 (
                  SYMLINK
                 	PropsChanged
                 )
                )
                (
                 pat_or
                 (
                  pat_or
                  (
                   FILE
                   SYMLINK
                  )
                  DIRECTORY
                 )
                	Deleted
                )
               )
               "assert false"
              )
            )
          )
         )
    )
   )
  sequence
  (
    test
    (
        "jerome_constr"
        replicaContent2shortString
        (
         ABSENT
        	Unchanged
        )
        "        "
    )
  ;
    sequence
    (
      test
      (
          "jerome_constr"
          replicaContent2shortString
          (
           ABSENT
          	Deleted
          )
          "deleted "
      )
    ;
      sequence
      (
        test
        (
            "jerome_constr"
            replicaContent2shortString
            (
             FILE
            	Modified
            )
            "changed "
        )
      ;
        sequence
        (
          test
          (
              "jerome_constr"
              replicaContent2shortString
              (
               DIRECTORY
              	PropsChanged
              )
              "props   "
          )
        ;
          sequence
          (
            test
            (
                "jerome_constr"
                replicaContent2shortString
                (
                 FILE
                	Deleted
                )
                "assert false"
            )
          ;
            sequence
            (
              test
              (
                  "jerome_constr"
                  replicaContent2shortString
                  (
                   SYMLINK
                  	Deleted
                  )
                  "assert false"
              )
            ;
              sequence
              (
                test
                (
                    "jerome_constr"
                    replicaContent2shortString
                    (
                     SYMLINK
                    	PropsChanged
                    )
                    "assert false"
                )
              ;
                sequence
                (
                  test
                  (
                      "jerome_constr"
                      replicaContent2shortString
                      (
                       DIRECTORY
                      	Deleted
                      )
                      "assert false"
                  )
                ;
                  sequence
                  (
                    test
                    (
                        "jerome_constr"
                        replicaContent2shortString
                        (
                         ABSENT
                        	Created
                        )
                        "assert false"
                    )
                  ;
                    sequence
                    (
                      test
                      (
                          "jerome_constr"
                          replicaContent2shortString
                          (
                           ABSENT
                          	Modified
                          )
                          "assert false"
                      )
                    ;
                      test
                      (
                          "jerome_constr"
                          replicaContent2shortString
                          (
                           ABSENT
                          	PropsChanged
                          )
                          "assert false"
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
   let
   (
     replicaContent2shortString
    (
     case
         (
     	  rc
          let
          (
           (
             (
              typ
             	status
             )
             rc 
           )
          in
            match
            (
             typ
            	status
            )
            (
            case
            (
              (
               _
              	Unchanged
              )
              "        "
            ) 
              case
              (
               (
                ABSENT
               	Deleted
               )
               "deleted "
              )
              case
              (
               (
                FILE
               	Created
               )
               "new file"
              )
              case
              (
               (
                FILE
               	Modified
               )
               "changed "
              )
              case
              (
               (
                FILE
               	PropsChanged
               )
               "props   "
              )
              case
              (
               (
                SYMLINK
               	Created
               )
               "new link"
              )
              case
              (
               (
                SYMLINK
               	Modified
               )
               "chgd lnk"
              )
              case
              (
               (
                DIRECTORY
               	Created
               )
               "new dir "
              )
              case
              (
               (
                DIRECTORY
               	Modified
               )
               "chgd dir"
              )
              case
              (
               (
                DIRECTORY
               	PropsChanged
               )
               "props   "
              )
              case
              (
               pat_or
               (
                pat_or
                (
                 (
                  ABSENT
                 	pat_or
                 	(
                 	 pat_or
                 	 (
                 	  Created
                 	  Modified
                 	 )
                 	 PropsChanged
                 	)
                 )
                 (
                  SYMLINK
                 	PropsChanged
                 )
                )
                (
                 pat_or
                 (
                  pat_or
                  (
                   FILE
                   SYMLINK
                  )
                  DIRECTORY
                 )
                	Deleted
                )
               )
               "assert false"
              )
            )
          )
         )
    )
   )
  sequence
  (
    test
    (
        "jerome_variant"
        replicaContent2shortString
        (
         ABSENT
        	Unchanged
        )
        "        "
    )
  ;
    sequence
    (
      test
      (
          "jerome_variant"
          replicaContent2shortString
          (
           ABSENT
          	Deleted
          )
          "deleted "
      )
    ;
      sequence
      (
        test
        (
            "jerome_variant"
            replicaContent2shortString
            (
             FILE
            	Modified
            )
            "changed "
        )
      ;
        sequence
        (
          test
          (
              "jerome_variant"
              replicaContent2shortString
              (
               DIRECTORY
              	PropsChanged
              )
              "props   "
          )
        ;
          sequence
          (
            test
            (
                "jerome_variant"
                replicaContent2shortString
                (
                 FILE
                	Deleted
                )
                "assert false"
            )
          ;
            sequence
            (
              test
              (
                  "jerome_variant"
                  replicaContent2shortString
                  (
                   SYMLINK
                  	Deleted
                  )
                  "assert false"
              )
            ;
              sequence
              (
                test
                (
                    "jerome_variant"
                    replicaContent2shortString
                    (
                     SYMLINK
                    	PropsChanged
                    )
                    "assert false"
                )
              ;
                sequence
                (
                  test
                  (
                      "jerome_variant"
                      replicaContent2shortString
                      (
                       DIRECTORY
                      	Deleted
                      )
                      "assert false"
                  )
                ;
                  sequence
                  (
                    test
                    (
                        "jerome_variant"
                        replicaContent2shortString
                        (
                         ABSENT
                        	Created
                        )
                        "assert false"
                    )
                  ;
                    sequence
                    (
                      test
                      (
                          "jerome_variant"
                          replicaContent2shortString
                          (
                           ABSENT
                          	Modified
                          )
                          "assert false"
                      )
                    ;
                      test
                      (
                          "jerome_variant"
                          replicaContent2shortString
                          (
                           ABSENT
                          	PropsChanged
                          )
                          "assert false"
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
   type
   (  						
      ab
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        A
        (
         int
         (
         )
        )
        B
        (
         int
         (
         )
        )
        )
   )
   type
   (  						
      cd
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        C
        (
        )
        D
        (
        )
        )
   )
   let
   (
     ohl
     (
      case
      (
        (
         pat_or
         (
          A
          p
          B
          p
         )
        	C
        )
        p
      ) 
        case
        (
         (
          pat_or
          (
           A
           p
           B
           p
          )
         	D
         )
         p
        )
     )
   )
  sequence
  (
    test
    (
        "ohl"
        ohl
        (
         A
            0
        	C
        )
        0
    )
  ;
    sequence
    (
      test
      (
          "ohl"
          ohl
          (
           B
              0
          	D
          )
          0
      )
    ;
      ()
    )
  )
   type
   (  						
      pottier
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        A
        (
        )
        B
        (
        )
        )
   )
   let
   (
     pottier
    (
     case
         (
     	  x
          match
          x
          (
          case
          (
            (
             pat_or
             (
              (
               A
              	1
              )
              (
               B
              	2
              )
             )
            	A
            )
            false
          ) 
            case
            (
             _
             true
            )
          )
         )
    )
   )
  sequence
  (
    test
    (
        "pottier"
        pottier
        (
         (
          B
         	2
         )
        	A
        )
        false
    )
  ;
    sequence
    (
      test
      (
          "pottier"
          pottier
          (
           (
            B
           	2
           )
          	B
          )
          true
      )
    ;
      sequence
      (
        test
        (
            "pottier"
            pottier
            (
             (
              A
             	2
             )
            	A
            )
            true
        )
      ;
        ()
      )
    )
  )
   let
   (
     coquery
    (
     case
         (
     	  q
          match
          q
          (
          case
          (
            (
             y
            	0
            	pat_or
            	(
            	 ::
            	 (
            	   modu
            	   ::
            	   (
            	     defs
            	     []
            	   )
            	 )
            	 ::
            	 (
            	   defs
            	   ::
            	   (
            	     modu
            	     ::
            	     (
            	       _
            	       []
            	     )
            	   )
            	 )
            	)
            )
            -
            (
                +
                (
                    y
                    defs
                )
                modu
            )
          ) 
            case
            (
             _
             0
            )
          )
         )
    )
   )
  sequence
  (
    test
    (
        "coquery"
        coquery
        (
         1
        	0
        	::
        	 (
        	 1
        	 ::
        	 (
        	 2
        	 ::
        	 (
        	 3
        	 []
        	 ) 
        	 ) 
        	 ) 
        )
        0
    )
  ;
    sequence
    (
      test
      (
          "coquery"
          coquery
          (
           1
          	0
          	::
          	 (
          	 1
          	 ::
          	 (
          	 2
          	 []
          	 ) 
          	 ) 
          )
          2
      )
    ;
      ()
    )
  )
   type
   (  						
      vars
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        A
        (
         int
         (
         )
        )
        B
        (
         tuple
         (
          int
          (
          )
           int
           (
           )
         )
        )
        C
        (
        )
        )
   )
   let
   (
     vars1
     (
      case
      (
        pat_or
        (
         A
         x
         B
         (
          _
         	x
         )
        )
        x
      ) 
        case
        (
         C
         0
        )
     )
   )
  sequence
  (
    test
    (
        "vars1"
        vars1
        A
           1
        1
    )
  ;
    sequence
    (
      test
      (
          "vars1"
          vars1
          B
             (
              1
             	2
             )
          2
      )
    ;
      ()
    )
  )
   let
   (
     vars2
     (
      case
      (
        pat_or
        (
         pat_or
         (
          ::
          (
            x
            []
          )
          ::
          (
            1
            ::
            (
              x
              []
            )
          )
         )
         ::
         (
           1
           ::
           (
             2
             ::
             (
               x
               []
             )
           )
         )
        )
        x
      ) 
        case
        (
         _
         0
        )
     )
   )
  sequence
  (
    test
    (
        "vars2"
        vars2
        ::
         (
         1
         []
         ) 
        1
    )
  ;
    sequence
    (
      test
      (
          "vars2"
          vars2
          ::
           (
           1
           ::
           (
           2
           []
           ) 
           ) 
          2
      )
    ;
      sequence
      (
        test
        (
            "vars2"
            vars2
            ::
             (
             1
             ::
             (
             2
             ::
             (
             3
             []
             ) 
             ) 
             ) 
            3
        )
      ;
        sequence
        (
          test
          (
              "vars2"
              vars2
              ::
               (
               0
               ::
               (
               0
               []
               ) 
               ) 
              0
          )
        ;
          ()
        )
      )
    )
  )
   type
   (  						
      eber
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
         x
         poly
         int
         (
         )
         y
         poly
         int
         (
         )
         z
         poly
         bool
         (
         )
        )
   )
   let
   (
     eber
     (
      case
      (
        pat_or
        (
         patternRec 
         (
             x
             a
             <"field_name"("z")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"patternConstant"("trueConstant"()[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
         )
         patternRec 
         (
             y
             a
             <"field_name"("z")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"patternConstant"("falseConstant"()[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
         )
        )
        a
      ) 
     )
   )
  sequence
  (
    test
    (
        "eber"
        eber
        record
        (
         x
         0
           y
           1
           z
           true
        )
        0
    )
  ;
    sequence
    (
      test
      (
          "eber"
          eber
          record
          (
           x
           1
             y
             0
             z
             false
          )
          0
      )
    ;
      ()
    )
  )
   let
   (
     escaped
     (
      case
      (
        pat_or
        (
         pat_or
         (
          pat_or
          (
           22
           5c
          )
          0a
         )
         09
        )
        2
      ) 
        case
        (
         c
         1
        )
     )
   )
  sequence
  (
    test
    (
        "escaped"
        escaped
        22
        2
    )
  ;
    sequence
    (
      test
      (
          "escaped"
          escaped
          5c
          2
      )
    ;
      sequence
      (
        test
        (
            "escaped"
            escaped
            0a
            2
        )
      ;
        sequence
        (
          test
          (
              "escaped"
              escaped
              09
              2
          )
        ;
          sequence
          (
            test
            (
                "escaped"
                escaped
                00
                1
            )
          ;
            sequence
            (
              test
              (
                  "escaped"
                  escaped
                  20
                  1
              )
            ;
              sequence
              (
                test
                (
                    "escaped"
                    escaped
                    00
                    1
                )
              ;
                sequence
                (
                  test
                  (
                      "escaped"
                      escaped
                      5b
                      1
                  )
                ;
                  sequence
                  (
                    test
                    (
                        "escaped"
                        escaped
                        5d
                        1
                    )
                  ;
                    sequence
                    (
                      test
                      (
                          "escaped"
                          escaped
                          21
                          1
                      )
                    ;
                      sequence
                      (
                        test
                        (
                            "escaped"
                            escaped
                            23
                            1
                        )
                      ;
                        ()
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
   exception Unknown_Reply
   (
   int
   (
   )
   )
   type
   (  						
      command_reply
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        RPL_TRYAGAIN
        (
        )
        RPL_TRACEEND
        (
        )
        RPL_TRACELOG
        (
        )
        RPL_ADMINEMAIL
        (
        )
        RPL_ADMINLOC2
        (
        )
        RPL_ADMINLOC1
        (
        )
        RPL_ADMINME
        (
        )
        RPL_LUSERME
        (
        )
        RPL_LUSERCHANNELS
        (
        )
        RPL_LUSERUNKNOWN
        (
        )
        RPL_LUSEROP
        (
        )
        RPL_LUSERCLIENT
        (
        )
        RPL_STATSDLINE
        (
        )
        RPL_STATSDEBUG
        (
        )
        RPL_STATSDEFINE
        (
        )
        RPL_STATSBLINE
        (
        )
        RPL_STATSPING
        (
        )
        RPL_STATSSLINE
        (
        )
        RPL_STATSHLINE
        (
        )
        RPL_STATSOLINE
        (
        )
        RPL_STATSUPTIME
        (
        )
        RPL_STATSLLINE
        (
        )
        RPL_STATSVLINE
        (
        )
        RPL_SERVLISTEND
        (
        )
        RPL_SERVLIST
        (
        )
        RPL_SERVICE
        (
        )
        RPL_ENDOFSERVICES
        (
        )
        RPL_SERVICEINFO
        (
        )
        RPL_UMODEIS
        (
        )
        RPL_ENDOFSTATS
        (
        )
        RPL_STATSYLINE
        (
        )
        RPL_STATSQLINE
        (
        )
        RPL_STATSKLINE
        (
        )
        RPL_STATSILINE
        (
        )
        RPL_STATSNLINE
        (
        )
        RPL_STATSCLINE
        (
        )
        RPL_STATSCOMMANDS
        (
        )
        RPL_STATSLINKINFO
        (
        )
        RPL_TRACERECONNECT
        (
        )
        RPL_TRACECLASS
        (
        )
        RPL_TRACENEWTYPE
        (
        )
        RPL_TRACESERVICE
        (
        )
        RPL_TRACESERVER
        (
        )
        RPL_TRACEUSER
        (
        )
        RPL_TRACEOPERATOR
        (
        )
        RPL_TRACEUNKNOWN
        (
        )
        RPL_TRACEHANDSHAKE
        (
        )
        RPL_TRACECONNECTING
        (
        )
        RPL_TRACELINK
        (
        )
        RPL_NOUSERS
        (
        )
        RPL_ENDOFUSERS
        (
        )
        RPL_USERS
        (
        )
        RPL_USERSSTART
        (
        )
        RPL_TIME
        (
        )
        RPL_NOTOPERANYMORE
        (
        )
        RPL_MYPORTIS
        (
        )
        RPL_YOURESERVICE
        (
        )
        RPL_REHASHING
        (
        )
        RPL_YOUREOPER
        (
        )
        RPL_ENDOFMOTD
        (
        )
        RPL_MOTDSTART
        (
        )
        RPL_ENDOFINFO
        (
        )
        RPL_INFOSTART
        (
        )
        RPL_MOTD
        (
        )
        RPL_INFO
        (
        )
        RPL_ENDOFBANLIST
        (
        )
        RPL_BANLIST
        (
        )
        RPL_ENDOFLINKS
        (
        )
        RPL_LINKS
        (
        )
        RPL_CLOSEEND
        (
        )
        RPL_CLOSING
        (
        )
        RPL_KILLDONE
        (
        )
        RPL_ENDOFNAMES
        (
        )
        RPL_NAMREPLY
        (
        )
        RPL_ENDOFWHO
        (
        )
        RPL_WHOREPLY
        (
        )
        RPL_VERSION
        (
        )
        RPL_SUMMONING
        (
        )
        RPL_INVITING
        (
        )
        RPL_TOPIC
        (
        )
        RPL_NOTOPIC
        (
        )
        RPL_CHANNELMODEIS
        (
        )
        RPL_LISTEND
        (
        )
        RPL_LIST
        (
        )
        RPL_LISTSTART
        (
        )
        RPL_WHOISCHANNELS
        (
        )
        RPL_ENDOFWHOIS
        (
        )
        RPL_WHOISIDLE
        (
        )
        RPL_WHOISCHANOP
        (
        )
        RPL_ENDOFWHOWAS
        (
        )
        RPL_WHOWASUSER
        (
        )
        RPL_WHOISOPERATOR
        (
        )
        RPL_WHOISSERVER
        (
        )
        RPL_WHOISUSER
        (
        )
        RPL_NOWAWAY
        (
        )
        RPL_UNAWAY
        (
        )
        RPL_TEXT
        (
        )
        RPL_ISON
        (
        )
        RPL_USERHOST
        (
        )
        RPL_AWAY
        (
        )
        RPL_NONE
        (
        )
        )
   )
   let
   (
     get_command_reply
    (
     case
         (
     	  n
          match
          n
          (
          case
          (
            263
            RPL_TRYAGAIN
          ) 
            case
            (
             319
             RPL_WHOISCHANNELS
            )
            case
            (
             318
             RPL_ENDOFWHOIS
            )
            case
            (
             317
             RPL_WHOISIDLE
            )
            case
            (
             316
             RPL_WHOISCHANOP
            )
            case
            (
             369
             RPL_ENDOFWHOWAS
            )
            case
            (
             314
             RPL_WHOWASUSER
            )
            case
            (
             313
             RPL_WHOISOPERATOR
            )
            case
            (
             312
             RPL_WHOISSERVER
            )
            case
            (
             311
             RPL_WHOISUSER
            )
            case
            (
             262
             RPL_TRACEEND
            )
            case
            (
             261
             RPL_TRACELOG
            )
            case
            (
             259
             RPL_ADMINEMAIL
            )
            case
            (
             258
             RPL_ADMINLOC2
            )
            case
            (
             257
             RPL_ADMINLOC1
            )
            case
            (
             256
             RPL_ADMINME
            )
            case
            (
             255
             RPL_LUSERME
            )
            case
            (
             254
             RPL_LUSERCHANNELS
            )
            case
            (
             253
             RPL_LUSERUNKNOWN
            )
            case
            (
             252
             RPL_LUSEROP
            )
            case
            (
             251
             RPL_LUSERCLIENT
            )
            case
            (
             250
             RPL_STATSDLINE
            )
            case
            (
             249
             RPL_STATSDEBUG
            )
            case
            (
             248
             RPL_STATSDEFINE
            )
            case
            (
             247
             RPL_STATSBLINE
            )
            case
            (
             246
             RPL_STATSPING
            )
            case
            (
             245
             RPL_STATSSLINE
            )
            case
            (
             244
             RPL_STATSHLINE
            )
            case
            (
             243
             RPL_STATSOLINE
            )
            case
            (
             242
             RPL_STATSUPTIME
            )
            case
            (
             241
             RPL_STATSLLINE
            )
            case
            (
             240
             RPL_STATSVLINE
            )
            case
            (
             235
             RPL_SERVLISTEND
            )
            case
            (
             234
             RPL_SERVLIST
            )
            case
            (
             233
             RPL_SERVICE
            )
            case
            (
             232
             RPL_ENDOFSERVICES
            )
            case
            (
             231
             RPL_SERVICEINFO
            )
            case
            (
             221
             RPL_UMODEIS
            )
            case
            (
             219
             RPL_ENDOFSTATS
            )
            case
            (
             218
             RPL_STATSYLINE
            )
            case
            (
             217
             RPL_STATSQLINE
            )
            case
            (
             216
             RPL_STATSKLINE
            )
            case
            (
             215
             RPL_STATSILINE
            )
            case
            (
             214
             RPL_STATSNLINE
            )
            case
            (
             213
             RPL_STATSCLINE
            )
            case
            (
             212
             RPL_STATSCOMMANDS
            )
            case
            (
             211
             RPL_STATSLINKINFO
            )
            case
            (
             210
             RPL_TRACERECONNECT
            )
            case
            (
             209
             RPL_TRACECLASS
            )
            case
            (
             208
             RPL_TRACENEWTYPE
            )
            case
            (
             207
             RPL_TRACESERVICE
            )
            case
            (
             206
             RPL_TRACESERVER
            )
            case
            (
             205
             RPL_TRACEUSER
            )
            case
            (
             204
             RPL_TRACEOPERATOR
            )
            case
            (
             203
             RPL_TRACEUNKNOWN
            )
            case
            (
             202
             RPL_TRACEHANDSHAKE
            )
            case
            (
             201
             RPL_TRACECONNECTING
            )
            case
            (
             200
             RPL_TRACELINK
            )
            case
            (
             395
             RPL_NOUSERS
            )
            case
            (
             394
             RPL_ENDOFUSERS
            )
            case
            (
             393
             RPL_USERS
            )
            case
            (
             392
             RPL_USERSSTART
            )
            case
            (
             391
             RPL_TIME
            )
            case
            (
             385
             RPL_NOTOPERANYMORE
            )
            case
            (
             384
             RPL_MYPORTIS
            )
            case
            (
             383
             RPL_YOURESERVICE
            )
            case
            (
             382
             RPL_REHASHING
            )
            case
            (
             381
             RPL_YOUREOPER
            )
            case
            (
             376
             RPL_ENDOFMOTD
            )
            case
            (
             375
             RPL_MOTDSTART
            )
            case
            (
             374
             RPL_ENDOFINFO
            )
            case
            (
             373
             RPL_INFOSTART
            )
            case
            (
             372
             RPL_MOTD
            )
            case
            (
             371
             RPL_INFO
            )
            case
            (
             368
             RPL_ENDOFBANLIST
            )
            case
            (
             367
             RPL_BANLIST
            )
            case
            (
             365
             RPL_ENDOFLINKS
            )
            case
            (
             364
             RPL_LINKS
            )
            case
            (
             363
             RPL_CLOSEEND
            )
            case
            (
             362
             RPL_CLOSING
            )
            case
            (
             361
             RPL_KILLDONE
            )
            case
            (
             366
             RPL_ENDOFNAMES
            )
            case
            (
             353
             RPL_NAMREPLY
            )
            case
            (
             315
             RPL_ENDOFWHO
            )
            case
            (
             352
             RPL_WHOREPLY
            )
            case
            (
             351
             RPL_VERSION
            )
            case
            (
             342
             RPL_SUMMONING
            )
            case
            (
             341
             RPL_INVITING
            )
            case
            (
             332
             RPL_TOPIC
            )
            case
            (
             331
             RPL_NOTOPIC
            )
            case
            (
             324
             RPL_CHANNELMODEIS
            )
            case
            (
             323
             RPL_LISTEND
            )
            case
            (
             322
             RPL_LIST
            )
            case
            (
             321
             RPL_LISTSTART
            )
            case
            (
             306
             RPL_NOWAWAY
            )
            case
            (
             305
             RPL_UNAWAY
            )
            case
            (
             304
             RPL_TEXT
            )
            case
            (
             303
             RPL_ISON
            )
            case
            (
             302
             RPL_USERHOST
            )
            case
            (
             301
             RPL_AWAY
            )
            case
            (
             300
             RPL_NONE
            )
            case
            (
             _
             raise
             (
                 Unknown_Reply
                    n
             )
            )
          )
         )
    )
   )
   type
   (  						
      habert_a
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        A
        (
         habert_c
         (
         )
        )
        B
        (
         habert_c
         (
         )
        )
        )
      habert_c
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
         lvar
         poly
         int
         (
         )
         lassoc
         poly
         habert_c
         (
         )
         lnb
         poly
         int
         (
         )
        )
   )
   let
   (
     habert
     (
      case
      (
        pat_or
        (
         A
         patternRec 
         (
             lnb
             i
         )
         B
         patternRec 
         (
             lnb
             i
         )
        )
        when
        =
        (
            i
            0
        )
        1
      ) 
        case
        (
         A
         patternRec 
         (
             lassoc
             patternRec 
             (
                 lnb
                 j
             )
             <"field_name"("lnb")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"patternValueName"("i")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
         )
         2
        )
        case
        (
         _
         3
        )
     )
   )
  let
  (
   (
     ex0
     record
     (
      lvar
      0
        lnb
        0
        lassoc
        ex1
     ) 
     ex1
     record
     (
      lvar
      1
        lnb
        1
        lassoc
        ex0
     ) 
   )
  in
    sequence
    (
      test
      (
          "habert"
          habert
          A
             ex0
          1
      )
    ;
      sequence
      (
        test
        (
            "habert"
            habert
            B
               ex0
            1
        )
      ;
        sequence
        (
          test
          (
              "habert"
              habert
              A
                 ex1
              2
          )
        ;
          test
          (
              "habert"
              habert
              B
                 ex1
              3
          )
        )
      )
    )
  )
   type
   (  						
      type_expr
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        <[],[<"TTuple",["typexprConstr1"("typexprConstr2"("typeConstr"([],"type_expr")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"typeConstr"([],"list")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>,<"TConstr",["typexprConstr1"("typexprConstr2"("typeConstr"([],"type_expr")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"typeConstr"([],"list")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>,<"TVar",["typexprConstr2"("typeConstr"([],"string")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>,<"TVariant",["typexprConstr1"("typexprConstr2"("typeConstr"([],"string")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"typeConstr"([],"list")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>,<"TBlock",["typexprConstr2"("typeConstr"([],"int")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>,<"TCopy",["typexprConstr2"("typeConstr"([],"type_expr")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>]>
      recurs_type_expr
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        <[],[<"TTuple",["typexprConstr1"("typexprConstr2"("typeConstr"([],"type_expr")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"typeConstr"([],"list")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>,<"TConstr",["typexprConstr1"("typexprConstr2"("typeConstr"([],"type_expr")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"typeConstr"([],"list")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>,<"TVariant",["typexprConstr1"("typexprConstr2"("typeConstr"([],"string")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"typeConstr"([],"list")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>]>
   )
   let
   (
     maf
    (
     case
         (
     	  te
          match
          te
          (
          case
          (
            TCopy
            te
            1
          ) 
            case
            (
             TVar
             _
             2
            )
            case
            (
             TBlock
             _
             2
            )
            case
            (
             alias desc
             (
               recurs_type_expr
             )
             let
             (
              (
                te
                match
                desc
                (
                case
                (
                  TTuple
                  tl
                  4
                ) 
                  case
                  (
                   TConstr
                   tl
                   5
                  )
                  case
                  (
                   TVariant
                   row
                   6
                  )
                )
              )
             in
               te
             )
            )
          )
         )
    )
   )
   let
   (
     base
     TBlock
        0
   )
  sequence
  (
    test
    (
        "maf"
        maf
        TCopy
           base
        1
    )
  ;
    sequence
    (
      test
      (
          "maf"
          maf
          TVar
             "test"
          2
      )
    ;
      sequence
      (
        test
        (
            "maf"
            maf
            TBlock
               0
            2
        )
      ;
        sequence
        (
          test
          (
              "maf"
              maf
              TTuple
                 []
              4
          )
        ;
          sequence
          (
            test
            (
                "maf"
                maf
                TConstr
                   []
                5
            )
          ;
            test
            (
                "maf"
                maf
                TVariant
                   []
                6
            )
          )
        )
      )
    )
  )
   type
   (  						
      t_seb
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        Uin
        (
        )
        Uout
        (
        )
        )
   )
   let
   (
     seb
     (
      case
      (
        (
         pat_or
         (
          (
           i
          	Uin
          )
          (
           i
          	Uout
          )
         )
        	Uout
        )
        1
      ) 
        case
        (
         (
          pat_or
          (
           (
            j
           	Uin
           )
           (
            j
           	Uout
           )
          )
         	Uin
         )
         2
        )
     )
   )
  sequence
  (
    test
    (
        "seb"
        seb
        (
         (
          0
         	Uin
         )
        	Uout
        )
        1
    )
  ;
    sequence
    (
      test
      (
          "seb"
          seb
          (
           (
            0
           	Uout
           )
          	Uin
          )
          2
      )
    ;
      ()
    )
  )
   type
   (  						
      t_j
        type
        params=
        (
          a
          b
        )
        cstrs =
        (
        )
        kind =
        (
        A
        (
         a
        )
        B
        (
         b
         a
        )
        C
        (
        )
        )
   )
   let
   (
     f
     (
      case
      (
        A
        pat_or
        (
         A
         C
        )
        0
      ) 
        case
        (
         B
         (
          B
         	D
         )
         1
        )
        case
        (
         C
         2
        )
     )
   )
   let
   (
     g
    (
     case
         (
     	  x
          try
          f
          (
              x
          )
          (
          case
          (
            Match_failure
            _
            3
          ) 
          )
         )
    )
   )
    sequence
    (
      test
      (
          "jacques"
          g
          A
             A
          0
      )
    ;
      sequence
      (
        test
        (
            "jacques"
            g
            A
               C
            0
        )
      ;
        sequence
        (
          test
          (
              "jacques"
              g
              B
                 (
                  B
                 	D
                 )
              1
          )
        ;
          sequence
          (
            test
            (
                "jacaues"
                g
                C
                2
            )
          ;
            ()
          )
        )
      )
    )
   type
   (  						
      t_l
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
        A
        (
        )
        B
        (
        )
        )
   )
   let
   (
     f
     (
      case
      (
        (
         _
        	_
        	_
        	_
        	_
        	_
        	_
        	_
        	_
        	_
        	_
        	_
        	_
        	B
        	_
        	_
        )
        "0"
      ) 
        case
        (
         (
          _
         	_
         	_
         	B
         	A
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         )
         "1"
        )
        case
        (
         (
          _
         	_
         	_
         	B
         	_
         	A
         	_
         	_
         	A
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         )
         "2"
        )
        case
        (
         (
          _
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	B
         	A
         	_
         	A
         	_
         	_
         )
         "3"
        )
        case
        (
         (
          _
         	_
         	_
         	_
         	_
         	_
         	_
         	B
         	_
         	_
         	_
         	_
         	B
         	_
         	A
         	A
         )
         "4"
        )
        case
        (
         (
          A
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         )
         "5"
        )
        case
        (
         (
          _
         	_
         	_
         	_
         	_
         	_
         	_
         	B
         	_
         	B
         	_
         	_
         	_
         	_
         	_
         	_
         )
         "6"
        )
        case
        (
         (
          _
         	B
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         )
         "7"
        )
        case
        (
         (
          _
         	A
         	A
         	_
         	A
         	_
         	B
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	B
         )
         "8"
        )
        case
        (
         (
          _
         	_
         	_
         	_
         	B
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	B
         	_
         )
         "9"
        )
        case
        (
         (
          _
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	B
         	_
         	_
         	_
         	_
         )
         "10"
        )
        case
        (
         (
          _
         	_
         	_
         	_
         	_
         	A
         	_
         	_
         	_
         	_
         	B
         	_
         	_
         	_
         	_
         	_
         )
         "11"
        )
        case
        (
         (
          B
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         )
         "12"
        )
        case
        (
         (
          _
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         	_
         )
         "13"
        )
     )
   )
    sequence
    (
      test
      (
          "luc"
          f
          (
           B
          	A
          	A
          	A
          	A
          	A
          	A
          	A
          	A
          	A
          	A
          	B
          	A
          	A
          	A
          	A
          )
          "10"
      )
    ;
      sequence
      (
        test
        (
            "luc"
            f
            (
             B
            	A
            	A
            	A
            	A
            	A
            	A
            	A
            	A
            	A
            	A
            	A
            	A
            	A
            	A
            	A
            )
            "12"
        )
      ;
        ()
      )
    )
   type
   (  						
      bg
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        <[],[<"False",[]>,<"True",[]>]>
   )
   type
   (  						
      vg
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        <[],[<"A",[]>,<"B",[]>,<"U",["typexprConstr2"("typeConstr"([],"int")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>,<"V",["typexprConstr2"("typeConstr"([],"int")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>]>
   )
   type
   (  						
      tg
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        (
         v
         poly
         vg
         (
         )
         x
         poly
         bg
         (
         )
        )
   )
   let
   (
     predg
    (
     case
         (
     	  x
          true
         )
    )
   )
   let
   (
     gilles
    (
     case
         (
     	  o
          match
          o
          (
          case
          (
            patternRec 
            (
                v
                pat_or
                (
                 U
                 data
                 V
                 data
                )
                <"field_name"("x")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"patternConstant"("False")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
            )
            when
            predg
            (
                o
            )
            1
          ) 
            case
            (
             pat_or
             (
              pat_or
              (
               patternRec 
               (
                   v
                   pat_or
                   (
                    A
                    B
                   )
                   <"field_name"("x")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"patternConstant"("False")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
               )
               patternRec 
               (
                   v
                   pat_or
                   (
                    U
                    _
                    V
                    _
                   )
                   <"field_name"("x")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"patternConstant"("False")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
               )
              )
              patternRec 
              (
                  v
                  _
                  <"field_name"("x")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"patternConstant"("True")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
              )
             )
             2
            )
          )
         )
    )
   )
   exception Found
   (
   string
   (
   )
   int
   (
   )
   )
   exception Error
   (
   string
   (
   )
   )
   let
   (
     lucexn
    (
     case
         (
     	  e
          try
          try
          raise
          (
              e
          )
          (
          case
          (
            Error
            msg
            msg
          ) 
          )
          (
          case
          (
            Found
            (
             s
            	r
            )
            ^
            (
                s
                string_of_int
                (
                    r
                )
            )
          ) 
          )
         )
    )
   )
   let
   (
     ()
     sequence
     (
       test
       (
           "lucexn1"
           lucexn
           Error
              "coucou"
           "coucou"
       )
     ;
       sequence
       (
         test
         (
             "lucexn2"
             lucexn
             Found
                (
                 "int: "
                	0
                )
             "int: 0"
         )
       ;
         ()
       )
     )
   )
   let
   (
      pr5758
    (
     case
         (
      		 x
      		(
      		 case
      		     (
      		 	  str
      		      match
      		      (
      		       x
      		      	str
      		      )
      		      (
      		      case
      		      (
      		        (
      		         1.
      		        	"A"
      		        )
      		        "Matched A"
      		      ) 
      		        case
      		        (
      		         (
      		          1.0
      		         	"B"
      		         )
      		         "Matched B"
      		        )
      		        case
      		        (
      		         (
      		          1.
      		         	"C"
      		         )
      		         "Matched C"
      		        )
      		        case
      		        (
      		         result
      		         match
      		         result
      		         (
      		         case
      		         (
      		           (
      		            1.
      		           	"A"
      		           )
      		           "Failed match A then later matched"
      		         ) 
      		           case
      		           (
      		            _
      		            "Failed twice"
      		           )
      		         )
      		        )
      		      )
      		     )
      		)
         )
    )
   )
   let
   (
     ()
     test
     (
         "pr5758"
         pr5758
         (
             1.
         )
         "A"
         "Matched A"
     ) 
   )
)
