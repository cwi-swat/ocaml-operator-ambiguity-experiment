
(
    								 
  open Terms
                                     
  type
  (  						
      							    	 
     rule
       type
       params=
       (
       
       )
       cstrs =
       (
       )
       kind =
       
       
       (
       							     
        
        number
        poly
        
        int
        (
        )
        								  
                                               
       							     
        
        numvars
        poly
        
        int
        (
        )
        								  
                                               
       							     
        
        lhs
        poly
        
        term
        (
        )
        								  
                                               
       							     
        
        rhs
        poly
        
        term
        (
        )
        								  
                                               
       							     
       )
       	                           
       														  
       														 
    											   
  								        
  )
                                     
  let
  (
   
    mk_rule
   (
    case
        (
     		
     		 num
     		(
     		 case
     		     (
     		  		
     		  		 m
     		  		(
     		  		 case
     		  		     (
     		  		 	  n
     		  		      
     		  		      let
     		  		      (
     		  		       (
     		  		          									  
     		  		        
     		  		         all_vars
     		  		         union
     		  		         (
     		  		             vars
     		  		             (
     		  		                 m
     		  		             )
     		  		             vars
     		  		             (
     		  		                 n
     		  		             )
     		  		         ) 
     		  		        							    		   
     		  		          									  
     		  		       )
     		  		      in
     		  		        
     		  		        let
     		  		        (
     		  		         (
     		  		            									  
     		  		          
     		  		           counter
     		  		           ref
     		  		           (
     		  		               0
     		  		           ) 
     		  		          							    		   
     		  		            									  
     		  		         )
     		  		        in
     		  		          
     		  		          let
     		  		          (
     		  		           (
     		  		              									  
     		  		            
     		  		             subst
     		  		             List.map
     		  		             (
     		  		                 (
     		  		                  
     		  		                  case
     		  		                  (
     		  		                  v
     		  		                  
     		  		                  
     		  		                  sequence
     		  		                  (
     		  		                    incr
     		  		                    (
     		  		                        counter
     		  		                    )
     		  		                  ;
     		  		                    
     		  		                        					 (
     		  		                          					   v
     		  		                        					   
     		  		                    	
     		  		                    	Var
     		  		                    	   
     		  		                    	    !
     		  		                    	    (
     		  		                    	    counter
     		  		                    	    )
     		  		                    	       							 
     		  		                    	    								 
     		  		                        					   
     		  		                        					 )
     		  		                  )
     		  		                      							
     		  		                  )
     		  		                  													 
     		  		                 )
     		  		                    						  
     		  		                 List.rev
     		  		                 (
     		  		                     all_vars
     		  		                 )
     		  		             ) 
     		  		            							    		   
     		  		              									  
     		  		           )
     		  		          in
     		  		            record
     		  		            (
     		  		             number
     		  		             num
     		  		            										   	     
     		  		              
     		  		               numvars
     		  		               
     		  		                !
     		  		                (
     		  		                counter
     		  		                )
     		  		                   							 
     		  		              										   
     		  		            											   	 
     		  		              
     		  		               lhs
     		  		               substitute
     		  		               (
     		  		                   subst
     		  		                   m
     		  		               )
     		  		              										   
     		  		            											   	 
     		  		              
     		  		               rhs
     		  		               substitute
     		  		               (
     		  		                   subst
     		  		                   n
     		  		               )
     		  		              										   
     		  		            											   	 
     		  		            )
     		  		          )
     		  		              									
     		  		        )
     		  		            									
     		  		      )
     		  		          									
     		  		     )
     		  		)
     		  		    		   
     		     )
     		)
     		    		   
        )
   )
       		    
  )
                                     
  let
  (
   
    check_rules
   (
    case
        (
    	  rules
         
         let
         (
          (
             									  
           
            counter
            ref
            (
                0
            ) 
           							    		   
             									  
          )
         in
           
           sequence
           (
             List.iter
             (
                 (
                  
                  case
                  (
                  r
                  
                  
                  sequence
                  (
                    incr
                    (
                        counter
                    )
                  ;
                    ifthenelse
                    (
                     if
                     (
                      <>
                      (
                          field
                          (
                          r
                          number
                          )
                              									 
                          
                           !
                           (
                           counter
                           )
                              							 
                      )
                     )
                     then
                     (
                      failwith
                      (
                          "Rule numbers not in sequence"
                      )
                     )
                     else
                     (
                     )
                    )
                        									   
                  )
                      							
                  )
                  													 
                 )
                    						  
                 rules
             )
           ;
             
              !
              (
              counter
              )
                 							 
           )
               							
         )
             									
        )
   )
       		    
  )
                                     
  let
  (
   
    pretty_rule
   (
    case
        (
    	  rule
         
         sequence
         (
           print_int
           (
               field
               (
               rule
               number
               )
                   									 
           )
         ;
           
           sequence
           (
             print_string
             (
                 " : "
             )
           ;
             
             sequence
             (
               pretty_term
               (
                   field
                   (
                   rule
                   lhs
                   )
                       									 
               )
             ;
               
               sequence
               (
                 print_string
                 (
                     " = "
                 )
               ;
                 
                 sequence
                 (
                   pretty_term
                   (
                       field
                       (
                       rule
                       rhs
                       )
                           									 
                   )
                 ;
                   print_newline
                   (
                       ()
                   )
                 )
                     							
               )
                   							
             )
                 							
           )
               							
         )
             							
        )
   )
       		    
  )
                                     
  let
  (
   
    pretty_rules
   (
    case
        (
    	  rules
         List.iter
         (
             pretty_rule
             rules
         )
        )
   )
       		    
  )
                                     
  let
  (
   
    reduce
   (
    case
        (
     		
     		 l
     		(
     		 case
     		     (
     		  		
     		  		 m
     		  		(
     		  		 case
     		  		     (
     		  		 	  r
     		  		      substitute
     		  		      (
     		  		          matching
     		  		          (
     		  		              l
     		  		              m
     		  		          )
     		  		          r
     		  		      )
     		  		     )
     		  		)
     		  		    		   
     		     )
     		)
     		    		   
        )
   )
       		    
  )
                                     
  let
  (
   
    can_match
   (
    case
        (
     		
     		 l
     		(
     		 case
     		     (
     		 	  m
     		      
     		      try
     		      
     		      let
     		      (
     		       (
     		          									  
     		        
     		         _
     		         matching
     		         (
     		             l
     		             m
     		         ) 
     		        							    		   
     		          									  
     		       )
     		      in
     		        true
     		      )
     		          									
     		      (
     		      
     		      case
     		      (
     		        
     		        Failure
     		        _
     		        									  
     		        
     		        false
     		      ) 
     		      	        											 
     		      	        											 
     		      )
     		          							   
     		     )
     		)
     		    		   
        )
   )
       		    
  )
                                     
  let
  (
   
    reducible
   (
    case
        (
     		
     		 l
     		(
     		 case
     		     (
     		 	  m
     		      ||
     		      (
     		          can_match
     		          (
     		              l
     		              m
     		          )
     		          match
     		          m
     		          (
     		          
     		          case
     		          (
     		            
     		            Term
     		            
     		            (
     		             _
     		                 						 
     		            	sons
     		            
     		            )
     		            									  
     		            
     		            List.exists
     		            (
     		                reducible
     		                (
     		                    l
     		                )
     		                sons
     		            )
     		          ) 
     		          	        											 
     		            
     		            case
     		            (
     		             _
     		             
     		             false
     		            )
     		            													    
     		          	        											 
     		          	        											 
     		          )
     		          			   
     		      )
     		     )
     		)
     		    		   
        )
   )
       		    
  )
                                     
  let
  (
   
    mreduce
   (
    case
        (
     		
     		 rules
     		(
     		 case
     		     (
     		 	  m
     		      match
     		      rules
     		      (
     		      
     		      case
     		      (
     		        []
     		        
     		        failwith
     		        (
     		            "mreduce"
     		        )
     		      ) 
     		      	        											 
     		        
     		        case
     		        (
     		         
     		         ::
     		         (
     		             rule
     		             rest
     		         )
     		         
     		         
     		         try
     		         reduce
     		         (
     		             field
     		             (
     		             rule
     		             lhs
     		             )
     		                 									 
     		             m
     		             field
     		             (
     		             rule
     		             rhs
     		             )
     		                 									 
     		         )
     		         (
     		         
     		         case
     		         (
     		           
     		           Failure
     		           _
     		           									  
     		           
     		           mreduce
     		           (
     		               rest
     		               m
     		           )
     		         ) 
     		         	        											 
     		         	        											 
     		         )
     		             							   
     		        )
     		        													    
     		      	        											 
     		      	        											 
     		      )
     		      			   
     		     )
     		)
     		    		   
        )
   )
       		    
  )
                                     
  let
  (
   
    mrewrite1
   (
    case
        (
     		
     		 rules
     		(
     		 case
     		     (
     		 	  m
     		      
     		      try
     		      mreduce
     		      (
     		          rules
     		          m
     		      )
     		      (
     		      
     		      case
     		      (
     		        
     		        Failure
     		        _
     		        									  
     		        
     		        match
     		        m
     		        (
     		        
     		        case
     		        (
     		          
     		          Var
     		          n
     		          									  
     		          
     		          failwith
     		          (
     		              "mrewrite1"
     		          )
     		        ) 
     		        	        											 
     		          
     		          case
     		          (
     		           
     		           Term
     		           
     		           (
     		            f
     		                						 
     		           	sons
     		           
     		           )
     		           									  
     		           
     		           
     		           Term
     		              
     		                  					 (
     		                    					   f
     		                  					   
     		              	mrewrite1_sons
     		              	(
     		              	    rules
     		              	    sons
     		              	)
     		                  					   
     		                  					 )
     		               								 
     		          )
     		          													    
     		        	        											 
     		        	        											 
     		        )
     		        			   
     		      ) 
     		      	        											 
     		      	        											 
     		      )
     		          							   
     		     )
     		)
     		    		   
        )
   )
       		     
   mrewrite1_sons
  (
   case
       (
   	  rules
        (
         
         case
         (
           []
           
           failwith
           (
               "mrewrite1"
           )
         ) 
         	        											 
           
           case
           (
            
            ::
            (
                son
                rest
            )
            
            
            try
            ::
            (
                mrewrite1
                (
                    rules
                    son
                )
                rest
            )
            (
            
            case
            (
              
              Failure
              _
              									  
              
              ::
              (
                  son
                  mrewrite1_sons
                  (
                      rules
                      rest
                  )
              )
            ) 
            	        											 
            	        											 
            )
                							   
           )
           													    
         	        											 
         	        											 
        )
           							   
       )
  )
      		    
  )
                                     
  let
  (
   
    mrewrite_all
   (
    case
        (
     		
     		 rules
     		(
     		 case
     		     (
     		 	  m
     		      
     		      try
     		      mrewrite_all
     		      (
     		          rules
     		          mrewrite1
     		          (
     		              rules
     		              m
     		          )
     		      )
     		      (
     		      
     		      case
     		      (
     		        
     		        Failure
     		        _
     		        									  
     		        
     		        m
     		      ) 
     		      	        											 
     		      	        											 
     		      )
     		          							   
     		     )
     		)
     		    		   
        )
   )
       		    
  )
                                     
)