(
  open StdLabels
  open MoreLabels
  module Subst
      Map.Make
    (
      struct
      (
        type
        (
          t
            type
              params =
                (
                )
              cstrs =
                (
                )
              kind =
                     string
                    (
                    )
        )
        let
        (
          compare
            compare
        )
      )
    )
  module Names
      Set.Make
    (
      struct
      (
        type
        (
          t
            type
              params =
                (
                )
              cstrs =
                (
                )
              kind =
                     string
                    (
                    )
        )
        let
        (
          compare
            compare
        )
      )
    )
  let
  (
    lazy_fix
      (
        case
        (
          make
          let
          (
            (
              obj
                (
                  case
                  (
                    ()
                                        make
                    (
                        (
                        lazy
                        obj
                        (
                            ()
                                                    )
                        :
                             Lazy.t
                            (
                            )
                                                )
                    )
                  )
                )
            )
          in
            obj
            (
                ()
                            )
          )
        )
      )
  )
  let
  (
    !!
      Lazy.force
  )
  class_type
  (
    class_type_declaration
      params =
          (
            "a"
            "b"
          )
      name = ops
      expr =
        class_type
          signature
          class_signature
            (
                  poly
                    arrow
                      b
                       Names.t
                      (
                      )
                  poly
                    arrow
                    sub
                       Subst.t
                      (
                          a
                      )
                      arrow
                        b
                        a
                  poly
                    arrow
                      b
                      a
            )
  )
  type
  (
    var
      type
        params =
          (
          )
        cstrs =
          (
          )
        kind =
              (
                Var
                  (
                       string
                      (
                      )
                  )
              )
                )
  let
  (
    var
      class_structure
        (
          method subst
            (
              case
              (
                sub
                (
                  case
                  (
                    alias x
                    (
                      Var
                        s
                    )
                    try
                    Subst.find
                    (
                        s
                        sub
                    )
                    (
                      case
                      (
                        Not_found
                                                x
                      )
                    )
                  )
                )
              )
            )
                      method free
            (
              case
              (
                Var
                  s
                Names.singleton
                (
                    s
                )
              )
            )
                      method eval
            (
              case
              (
                alias v
                (
                  var
                )
                v
              )
            )
                    )
  )
  type
  (
    lambda
      type
        params =
          (
            a
          )
        cstrs =
          (
          )
        kind =
              (
                Var
                  (
                       string
                      (
                      )
                  )
                Abs
                  (
                      tuple
                      (
                           string
                          (
                          )
                          a
                      )
                  )
                App
                  (
                      tuple
                      (
                          a
                          a
                      )
                  )
              )
                )
  let
  (
    next_id
      let
      (
        (
          current
            ref
            (
                3
            )
        )
      in
        (
          case
          (
            ()
                        sequence
            (
              incr
              (
                  current
              )
            ;
              !
              (
                  current
              )
            )
          )
        )
      )
  )
  let
  (
    lambda_ops
      (
        case
        (
          ops
             Lazy.t
            (
                ops
                (
                    a
                    a
                )
            )
          let
          (
            (
              free
                lazy
                send free
                (
                  !!
                  (
                      ops
                  )
                )
              subst
                lazy
                send subst
                (
                  !!
                  (
                      ops
                  )
                )
              eval
                lazy
                send eval
                (
                  !!
                  (
                      ops
                  )
                )
            )
          in
            class_structure
              (
                method free
                  (
                    case
                    (
                      alias x
                      (
                        var
                      )
                      send free
                      (
                        var
                      )
                      (
                          x
                      )
                    )
                    case
                    (
                      Abs
                        (
                          s
                          t
                        )
                      Names.remove
                      (
                          s
                          !!
                          (
                              free
                          )
                          (
                              t
                          )
                      )
                    )
                    case
                    (
                      App
                        (
                          t1
                          t2
                        )
                      Names.union
                      (
                          !!
                          (
                              free
                          )
                          (
                              t1
                          )
                          !!
                          (
                              free
                          )
                          (
                              t2
                          )
                      )
                    )
                  )
                                  method map
                  (
                    case
                    (
                      f
                      (
                        case
                        (
                          alias x
                          (
                            var
                          )
                          x
                        )
                        case
                        (
                          alias l
                          (
                            Abs
                              (
                                s
                                t
                              )
                          )
                          let
                          (
                            (
                              t'
                                f
                                (
                                    t
                                )
                            )
                          in
                            ifthenelse
                            (
                              if
                              (
                                ==
                                (
                                    t
                                    t'
                                )
                              )
                              then
                              (
                                l
                              )
                              else
                              (
                                  Abs
                                    (
                                      s
                                      t'
                                    )
                              )
                            )
                          )
                        )
                        case
                        (
                          alias l
                          (
                            App
                              (
                                t1
                                t2
                              )
                          )
                          let
                          (
                            (
                              t'1
                                f
                                (
                                    t1
                                )
                              t'2
                                f
                                (
                                    t2
                                )
                            )
                          in
                            ifthenelse
                            (
                              if
                              (
                                &&
                                (
                                    ==
                                    (
                                        t'1
                                        t1
                                    )
                                    ==
                                    (
                                        t'2
                                        t2
                                    )
                                )
                              )
                              then
                              (
                                l
                              )
                              else
                              (
                                  App
                                    (
                                      t'1
                                      t'2
                                    )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                                  method subst
                  (
                    case
                    (
                      sub
                      (
                        case
                        (
                          alias x
                          (
                            var
                          )
                          send subst
                          (
                            var
                          )
                          (
                            sub
                              sub
                              x
                          )
                        )
                        case
                        (
                          alias l
                          (
                            Abs
                              (
                                s
                                t
                              )
                          )
                          let
                          (
                            (
                              used
                                !!
                                (
                                    free
                                )
                                (
                                    t
                                )
                            )
                          in
                            let
                            (
                              (
                                used_expr
                                  Subst.fold
                                  (
                                      sub
                                    init
                                      []
                                                                          f
                                      (
                                        case
                                        (
                                          key
                                          (
                                            case
                                            (
                                              data
                                              (
                                                case
                                                (
                                                  acc
                                                  ifthenelse
                                                  (
                                                    if
                                                    (
                                                      Names.mem
                                                      (
                                                          s
                                                          used
                                                      )
                                                    )
                                                    then
                                                    (
                                                      ::
                                                        (
                                                          data
                                                          acc
                                                        )
                                                    )
                                                    else
                                                    (
                                                        acc
                                                    )
                                                  )
                                                )
                                              )
                                            )
                                          )
                                        )
                                      )
                                  )
                              )
                            in
                              ifthenelse
                              (
                                if
                                (
                                  List.exists
                                  (
                                      used_expr
                                    f
                                      (
                                        case
                                        (
                                          t
                                          Names.mem
                                          (
                                              s
                                              !!
                                              (
                                                  free
                                              )
                                              (
                                                  t
                                              )
                                          )
                                        )
                                      )
                                  )
                                )
                                then
                                (
                                  let
                                  (
                                    (
                                      name
                                        ^
                                        (
                                            s
                                            string_of_int
                                            (
                                                next_id
                                                (
                                                    ()
                                                                                                    )
                                            )
                                        )
                                    )
                                  in
                                    Abs
                                      (
                                        name
                                        !!
                                        (
                                            subst
                                        )
                                        (
                                          sub
                                            Subst.add
                                            (
                                              key
                                                s
                                              data
                                                Var
                                                  name
                                                sub
                                            )
                                            t
                                        )
                                      )
                                  )
                                )
                                else
                                (
                                    send map
                                    (
                                      self
                                    )
                                    (
                                      f
                                        !!
                                        (
                                            subst
                                        )
                                        (
                                          sub
                                            Subst.remove
                                            (
                                                s
                                                sub
                                            )
                                        )
                                        l
                                    )
                                )
                              )
                            )
                          )
                        )
                        case
                        (
                          alias l
                          (
                            App
                              _
                          )
                          send map
                          (
                            self
                          )
                          (
                            f
                              !!
                              (
                                  subst
                              )
                              (
                                sub
                                  sub
                              )
                              l
                          )
                        )
                      )
                    )
                  )
                                  method eval
                  (
                    case
                    (
                      l
                      match
                      send map
                      (
                        self
                      )
                      (
                        f
                          !!
                          (
                              eval
                          )
                          l
                      )
                      (
                        case
                        (
                          App
                            (
                              Abs
                                (
                                  s
                                  t1
                                )
                              t2
                            )
                          !!
                          (
                              eval
                          )
                          (
                              !!
                              (
                                  subst
                              )
                              (
                                sub
                                  Subst.add
                                  (
                                    key
                                      s
                                    data
                                      t2
                                      Subst.empty
                                  )
                                  t1
                              )
                          )
                        )
                        case
                        (
                          t
                          t
                        )
                      )
                    )
                  )
                                )
          )
        )
      )
  )
  let
  (
    lambda
      lazy_fix
      (
          lambda_ops
      )
  )
  type
  (
    expr
      type
        params =
          (
            a
          )
        cstrs =
          (
          )
        kind =
              (
                Var
                  (
                       string
                      (
                      )
                  )
                Num
                  (
                       int
                      (
                      )
                  )
                Add
                  (
                      tuple
                      (
                          a
                          a
                      )
                  )
                Neg
                  (
                      a
                  )
                Mult
                  (
                      tuple
                      (
                          a
                          a
                      )
                  )
              )
                )
  let
  (
    expr_ops
      (
        case
        (
          ops
             Lazy.t
            (
                ops
                (
                    a
                    a
                )
            )
          let
          (
            (
              free
                lazy
                send free
                (
                  !!
                  (
                      ops
                  )
                )
              subst
                lazy
                send subst
                (
                  !!
                  (
                      ops
                  )
                )
              eval
                lazy
                send eval
                (
                  !!
                  (
                      ops
                  )
                )
            )
          in
            class_structure
              (
                method free
                  (
                    case
                    (
                      alias x
                      (
                        var
                      )
                      send free
                      (
                        var
                      )
                      (
                          x
                      )
                    )
                    case
                    (
                      Num
                        _
                      Names.empty
                    )
                    case
                    (
                      Add
                        (
                          x
                          y
                        )
                      Names.union
                      (
                          !!
                          (
                              free
                          )
                          (
                              x
                          )
                          !!
                          (
                              free
                          )
                          (
                              y
                          )
                      )
                    )
                    case
                    (
                      Neg
                        x
                      !!
                      (
                          free
                      )
                      (
                          x
                      )
                    )
                    case
                    (
                      Mult
                        (
                          x
                          y
                        )
                      Names.union
                      (
                          !!
                          (
                              free
                          )
                          (
                              x
                          )
                          !!
                          (
                              free
                          )
                          (
                              y
                          )
                      )
                    )
                  )
                                  method map
                  (
                    case
                    (
                      f
                      (
                        case
                        (
                          alias x
                          (
                            var
                          )
                          x
                        )
                        case
                        (
                          alias x
                          (
                            Num
                              _
                          )
                          x
                        )
                        case
                        (
                          alias e
                          (
                            Add
                              (
                                x
                                y
                              )
                          )
                          let
                          (
                            (
                              x'
                                f
                                (
                                    x
                                )
                              y'
                                f
                                (
                                    y
                                )
                            )
                          in
                            ifthenelse
                            (
                              if
                              (
                                &&
                                (
                                    ==
                                    (
                                        x
                                        x'
                                    )
                                    ==
                                    (
                                        y
                                        y'
                                    )
                                )
                              )
                              then
                              (
                                e
                              )
                              else
                              (
                                  Add
                                    (
                                      x'
                                      y'
                                    )
                              )
                            )
                          )
                        )
                        case
                        (
                          alias e
                          (
                            Neg
                              x
                          )
                          let
                          (
                            (
                              x'
                                f
                                (
                                    x
                                )
                            )
                          in
                            ifthenelse
                            (
                              if
                              (
                                ==
                                (
                                    x
                                    x'
                                )
                              )
                              then
                              (
                                e
                              )
                              else
                              (
                                  Neg
                                    x'
                              )
                            )
                          )
                        )
                        case
                        (
                          alias e
                          (
                            Mult
                              (
                                x
                                y
                              )
                          )
                          let
                          (
                            (
                              x'
                                f
                                (
                                    x
                                )
                              y'
                                f
                                (
                                    y
                                )
                            )
                          in
                            ifthenelse
                            (
                              if
                              (
                                &&
                                (
                                    ==
                                    (
                                        x
                                        x'
                                    )
                                    ==
                                    (
                                        y
                                        y'
                                    )
                                )
                              )
                              then
                              (
                                e
                              )
                              else
                              (
                                  Mult
                                    (
                                      x'
                                      y'
                                    )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                                  method subst
                  (
                    case
                    (
                      sub
                      (
                        case
                        (
                          alias x
                          (
                            var
                          )
                          send subst
                          (
                            var
                          )
                          (
                            sub
                              sub
                              x
                          )
                        )
                        case
                        (
                          alias e
                          (
                            expr
                          )
                          send map
                          (
                            self
                          )
                          (
                            f
                              !!
                              (
                                  subst
                              )
                              (
                                sub
                                  sub
                              )
                              e
                          )
                        )
                      )
                    )
                  )
                                  method eval
                  (
                    case
                    (
                      alias e
                      (
                        expr
                      )
                      match
                      send map
                      (
                        self
                      )
                      (
                        f
                          !!
                          (
                              eval
                          )
                          e
                      )
                      (
                        case
                        (
                          Add
                            (
                              Num
                                m
                              Num
                                n
                            )
                          Num
                            +
                            (
                                m
                                n
                            )
                        )
                        case
                        (
                          Neg
                            Num
                              n
                          Num
                            ~-
                            (
                                n
                            )
                        )
                        case
                        (
                          Mult
                            (
                              Num
                                m
                              Num
                                n
                            )
                          Num
                            *
                            (
                                m
                                n
                            )
                        )
                        case
                        (
                          e
                          e
                        )
                      )
                    )
                  )
                                )
          )
        )
      )
  )
  let
  (
    expr
      lazy_fix
      (
          expr_ops
      )
  )
  type
  (
    lexpr
      type
        params =
          (
            a
          )
        cstrs =
          (
          )
        kind =
              (
                     lambda
                    (
                        a
                    )
                     expr
                    (
                        a
                    )
              )
                )
  let
  (
    lexpr_ops
      (
        case
        (
          ops
             Lazy.t
            (
                ops
                (
                    a
                    a
                )
            )
          let
          (
            (
              lambda
                lambda_ops
                (
                    ops
                )
            )
          in
            let
            (
              (
                expr
                  expr_ops
                  (
                      ops
                  )
              )
            in
              class_structure
                (
                  method free
                    (
                      case
                      (
                        alias x
                        (
                          lambda
                        )
                        send free
                        (
                          lambda
                        )
                        (
                            x
                        )
                      )
                      case
                      (
                        alias x
                        (
                          expr
                        )
                        send free
                        (
                          expr
                        )
                        (
                            x
                        )
                      )
                    )
                                      method subst
                    (
                      case
                      (
                        sub
                        (
                          case
                          (
                            alias x
                            (
                              lambda
                            )
                            send subst
                            (
                              lambda
                            )
                            (
                              sub
                                sub
                                x
                            )
                          )
                          case
                          (
                            alias x
                            (
                              expr
                            )
                            send subst
                            (
                              expr
                            )
                            (
                              sub
                                sub
                                x
                            )
                          )
                        )
                      )
                    )
                                      method eval
                    (
                      case
                      (
                        alias x
                        (
                          lambda
                        )
                        send eval
                        (
                          lambda
                        )
                        (
                            x
                        )
                      )
                      case
                      (
                        alias x
                        (
                          expr
                        )
                        send eval
                        (
                          expr
                        )
                        (
                            x
                        )
                      )
                    )
                                    )
            )
          )
        )
      )
  )
  let
  (
    lexpr
      lazy_fix
      (
          lexpr_ops
      )
  )
  let
  (
    print
      (
        case
        (
          Var
            id
          print_string
          (
              id
          )
        )
        case
        (
          Abs
            (
              id
              l
            )
          sequence
          (
            print_string
            (
                ^
                (
                    " "
                    ^
                    (
                        id
                        " . "
                    )
                )
            )
          ;
            print
            (
                l
            )
          )
        )
        case
        (
          App
            (
              l1
              l2
            )
          sequence
          (
            print
            (
                l1
            )
          ;
            sequence
            (
              print_string
              (
                  " "
              )
            ;
              print
              (
                  l2
              )
            )
          )
        )
        case
        (
          Num
            x
          print_int
          (
              x
          )
        )
        case
        (
          Add
            (
              e1
              e2
            )
          sequence
          (
            print
            (
                e1
            )
          ;
            sequence
            (
              print_string
              (
                  " + "
              )
            ;
              print
              (
                  e2
              )
            )
          )
        )
        case
        (
          Neg
            e
          sequence
          (
            print_string
            (
                "-"
            )
          ;
            print
            (
                e
            )
          )
        )
        case
        (
          Mult
            (
              e1
              e2
            )
          sequence
          (
            print
            (
                e1
            )
          ;
            sequence
            (
              print_string
              (
                  " * "
              )
            ;
              print
              (
                  e2
              )
            )
          )
        )
      )
  )
  let
  (
    ()
          let
      (
        (
          e1
            send eval
            (
              lambda
            )
            (
                App
                  (
                    Abs
                      (
                        "x"
                        Var
                          "x"
                      )
                    Var
                      "y"
                  )
            )
        )
      in
        let
        (
          (
            e2
              send eval
              (
                expr
              )
              (
                  Add
                    (
                      Mult
                        (
                          Num
                            3
                          Neg
                            Num
                              2
                        )
                      Var
                        "x"
                    )
              )
          )
        in
          let
          (
            (
              e3
                send eval
                (
                  lexpr
                )
                (
                    Add
                      (
                        App
                          (
                            Abs
                              (
                                "x"
                                Mult
                                  (
                                    Var
                                      "x"
                                    Var
                                      "x"
                                  )
                              )
                            Num
                              2
                          )
                        Num
                          5
                      )
                )
            )
          in
            sequence
            (
              print
              (
                  e1
              )
            ;
              sequence
              (
                print_newline
                (
                    ()
                                    )
              ;
                sequence
                (
                  print
                  (
                      e2
                  )
                ;
                  sequence
                  (
                    print_newline
                    (
                        ()
                                            )
                  ;
                    sequence
                    (
                      print
                      (
                          e3
                      )
                    ;
                      print_newline
                      (
                          ()
                                                )
                    )
                  )
                )
              )
            )
          )
        )
      )
  )
)
