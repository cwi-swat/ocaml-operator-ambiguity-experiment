(
  open StdLabels
  open MoreLabels
  module Subst
      Map.Make
    (
      struct
      (
        type
        (
          t
            type
              params =
                (
                )
              cstrs =
                (
                )
              kind =
                     string
                    (
                    )
        )
        let
        (
          compare
            compare
        )
      )
    )
  module Names
      Set.Make
    (
      struct
      (
        type
        (
          t
            type
              params =
                (
                )
              cstrs =
                (
                )
              kind =
                     string
                    (
                    )
        )
        let
        (
          compare
            compare
        )
      )
    )
  let
  (
    lazy_fix
      (
        case
        (
          make
          let
          (
            (
              obj
                (
                  case
                  (
                    ()
                                        make
                    (
                        (
                        lazy
                        obj
                        (
                            ()
                                                    )
                        :
                             Lazy.t
                            (
                            )
                                                )
                    )
                  )
                )
            )
          in
            obj
            (
                ()
                            )
          )
        )
      )
  )
  let
  (
    !!
      Lazy.force
  )
  class_type
  (
    class_type_declaration
      params =
          (
            "a"
            "b"
          )
      name = ops
      expr =
        class_type
          signature
          class_signature
            (
                  poly
                    arrow
                      b
                       Names.t
                      (
                      )
                  poly
                    arrow
                    sub
                       Subst.t
                      (
                          a
                      )
                      arrow
                        b
                        a
                  poly
                    arrow
                      b
                      a
            )
  )
  type
  (
    var
      type
        params =
          (
          )
        cstrs =
          (
          )
        kind =
              Ptyp_variant closed=true
              (
                Rtag "Var" false
                  (
                       string
                      (
                      )
                  )
              )
                )
  class
  (
      params =
          (
            "a"
          )
      class name = var_ops
      class expr =
          class_structure
            (
              Pcf_constr ([35,806+2]..[35,806+25])
                  a
                  Ptyp_variant closed=false
                  (
                    Rinherit
                         var
                        (
                        )
                  )
                                method subst
                (
                  case
                  (
                    sub
                    (
                      case
                      (
                        alias x
                        (
                          Var
                            s
                        )
                        try
                        Subst.find
                        (
                            s
                            sub
                        )
                        (
                          case
                          (
                            Not_found
                                                        x
                          )
                        )
                      )
                    )
                  )
                )
                              method free
                (
                  case
                  (
                    Var
                      s
                    Names.singleton
                    (
                        s
                    )
                  )
                )
                              method eval
                (
                  case
                  (
                    alias v
                    (
                      pat_type                      var
                    )
                    v
                  )
                )
                            )
  )
  type
  (
    lambda
      type
        params =
          (
            a
          )
        cstrs =
          (
          )
        kind =
              Ptyp_variant closed=true
              (
                Rtag "Var" false
                  (
                       string
                      (
                      )
                  )
                Rtag "Abs" false
                  (
                      tuple
                      (
                           string
                          (
                          )
                          a
                      )
                  )
                Rtag "App" false
                  (
                      tuple
                      (
                          a
                          a
                      )
                  )
              )
                )
  let
  (
    next_id
      let
      (
        (
          current
            ref
            (
                3
            )
        )
      in
        (
          case
          (
            ()
                        sequence
            (
              incr
              (
                  current
              )
            ;
              !
              (
                  current
              )
            )
          )
        )
      )
  )
  class
  (
      params =
          (
            "a"
          )
      class name = lambda_ops
      class expr =
                    ops
             Lazy.t
            (
                ops
                (
                    a
                    a
                )
            )
            let
            (
              var
                (
                new var_ops
                :
                     var_ops
                    (
                        a
                    )
                                )
              free
                lazy
                send free
                (
                  !!
                  (
                      ops
                  )
                )
              subst
                lazy
                send subst
                (
                  !!
                  (
                      ops
                  )
                )
              eval
                lazy
                send eval
                (
                  !!
                  (
                      ops
                  )
                )
            )
              class_structure
                (
                  Pcf_constr ([57,1439+4]..[57,1439+33])
                      a
                      Ptyp_variant closed=false
                      (
                        Rinherit
                             lambda
                            (
                                a
                            )
                      )
                                        method free
                    (
                      case
                      (
                        alias x
                        (
                          pat_type                          var
                        )
                        send free
                        (
                          var
                        )
                        (
                            x
                        )
                      )
                      case
                      (
                        Abs
                          (
                            s
                            t
                          )
                        Names.remove
                        (
                            s
                            !!
                            (
                                free
                            )
                            (
                                t
                            )
                        )
                      )
                      case
                      (
                        App
                          (
                            t1
                            t2
                          )
                        Names.union
                        (
                            !!
                            (
                                free
                            )
                            (
                                t1
                            )
                            !!
                            (
                                free
                            )
                            (
                                t2
                            )
                        )
                      )
                    )
                                      method map
                    (
                      case
                      (
                        f
                        (
                          case
                          (
                            alias x
                            (
                              pat_type                              var
                            )
                            x
                          )
                          case
                          (
                            alias l
                            (
                              Abs
                                (
                                  s
                                  t
                                )
                            )
                            let
                            (
                              (
                                t'
                                  f
                                  (
                                      t
                                  )
                              )
                            in
                              ifthenelse
                              (
                                if
                                (
                                  ==
                                  (
                                      t
                                      t'
                                  )
                                )
                                then
                                (
                                  l
                                )
                                else
                                (
                                    Abs
                                      (
                                        s
                                        t'
                                      )
                                )
                              )
                            )
                          )
                          case
                          (
                            alias l
                            (
                              App
                                (
                                  t1
                                  t2
                                )
                            )
                            let
                            (
                              (
                                t'1
                                  f
                                  (
                                      t1
                                  )
                                t'2
                                  f
                                  (
                                      t2
                                  )
                              )
                            in
                              ifthenelse
                              (
                                if
                                (
                                  &&
                                  (
                                      ==
                                      (
                                          t'1
                                          t1
                                      )
                                      ==
                                      (
                                          t'2
                                          t2
                                      )
                                  )
                                )
                                then
                                (
                                  l
                                )
                                else
                                (
                                    App
                                      (
                                        t'1
                                        t'2
                                      )
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                                      method subst
                    (
                      case
                      (
                        sub
                        (
                          case
                          (
                            alias x
                            (
                              pat_type                              var
                            )
                            send subst
                            (
                              var
                            )
                            (
                                sub
                                x
                            )
                          )
                          case
                          (
                            alias l
                            (
                              Abs
                                (
                                  s
                                  t
                                )
                            )
                            let
                            (
                              (
                                used
                                  !!
                                  (
                                      free
                                  )
                                  (
                                      t
                                  )
                              )
                            in
                              let
                              (
                                (
                                  used_expr
                                    Subst.fold
                                    (
                                        sub
                                        []
                                                                                (
                                          case
                                          (
                                            key
                                            (
                                              case
                                              (
                                                data
                                                (
                                                  case
                                                  (
                                                    acc
                                                    ifthenelse
                                                    (
                                                      if
                                                      (
                                                        Names.mem
                                                        (
                                                            s
                                                            used
                                                        )
                                                      )
                                                      then
                                                      (
                                                        ::
                                                          (
                                                            data
                                                            acc
                                                          )
                                                      )
                                                      else
                                                      (
                                                          acc
                                                      )
                                                    )
                                                  )
                                                )
                                              )
                                            )
                                          )
                                        )
                                    )
                                )
                              in
                                ifthenelse
                                (
                                  if
                                  (
                                    List.exists
                                    (
                                        used_expr
                                        (
                                          case
                                          (
                                            t
                                            Names.mem
                                            (
                                                s
                                                !!
                                                (
                                                    free
                                                )
                                                (
                                                    t
                                                )
                                            )
                                          )
                                        )
                                    )
                                  )
                                  then
                                  (
                                    let
                                    (
                                      (
                                        name
                                          ^
                                          (
                                              s
                                              string_of_int
                                              (
                                                  next_id
                                                  (
                                                      ()
                                                                                                        )
                                              )
                                          )
                                      )
                                    in
                                      Abs
                                        (
                                          name
                                          !!
                                          (
                                              subst
                                          )
                                          (
                                              Subst.add
                                              (
                                                  s
                                                  Var
                                                    name
                                                  sub
                                              )
                                              t
                                          )
                                        )
                                    )
                                  )
                                  else
                                  (
                                      send map
                                      (
                                        self
                                      )
                                      (
                                          !!
                                          (
                                              subst
                                          )
                                          (
                                              Subst.remove
                                              (
                                                  s
                                                  sub
                                              )
                                          )
                                          l
                                      )
                                  )
                                )
                              )
                            )
                          )
                          case
                          (
                            alias l
                            (
                              App
                                _
                            )
                            send map
                            (
                              self
                            )
                            (
                                !!
                                (
                                    subst
                                )
                                (
                                    sub
                                )
                                l
                            )
                          )
                        )
                      )
                    )
                                      method eval
                    (
                      case
                      (
                        l
                        match
                        send map
                        (
                          self
                        )
                        (
                            !!
                            (
                                eval
                            )
                            l
                        )
                        (
                          case
                          (
                            App
                              (
                                Abs
                                  (
                                    s
                                    t1
                                  )
                                t2
                              )
                            !!
                            (
                                eval
                            )
                            (
                                !!
                                (
                                    subst
                                )
                                (
                                    Subst.add
                                    (
                                        s
                                        t2
                                        Subst.empty
                                    )
                                    t1
                                )
                            )
                          )
                          case
                          (
                            t
                            t
                          )
                        )
                      )
                    )
                                    )
  )
  let
  (
    lambda
      lazy_fix
      (
          new lambda_ops
      )
  )
  type
  (
    expr
      type
        params =
          (
            a
          )
        cstrs =
          (
          )
        kind =
              Ptyp_variant closed=true
              (
                Rtag "Var" false
                  (
                       string
                      (
                      )
                  )
                Rtag "Num" false
                  (
                       int
                      (
                      )
                  )
                Rtag "Add" false
                  (
                      tuple
                      (
                          a
                          a
                      )
                  )
                Rtag "Neg" false
                  (
                      a
                  )
                Rtag "Mult" false
                  (
                      tuple
                      (
                          a
                          a
                      )
                  )
              )
                )
  class
  (
      params =
          (
            "a"
          )
      class name = expr_ops
      class expr =
                    ops
             Lazy.t
            (
                ops
                (
                    a
                    a
                )
            )
            let
            (
              var
                (
                new var_ops
                :
                     var_ops
                    (
                        a
                    )
                                )
              free
                lazy
                send free
                (
                  !!
                  (
                      ops
                  )
                )
              subst
                lazy
                send subst
                (
                  !!
                  (
                      ops
                  )
                )
              eval
                lazy
                send eval
                (
                  !!
                  (
                      ops
                  )
                )
            )
              class_structure
                (
                  Pcf_constr ([112,3238+4]..[112,3238+31])
                      a
                      Ptyp_variant closed=false
                      (
                        Rinherit
                             expr
                            (
                                a
                            )
                      )
                                        method free
                    (
                      case
                      (
                        alias x
                        (
                          pat_type                          var
                        )
                        send free
                        (
                          var
                        )
                        (
                            x
                        )
                      )
                      case
                      (
                        Num
                          _
                        Names.empty
                      )
                      case
                      (
                        Add
                          (
                            x
                            y
                          )
                        Names.union
                        (
                            !!
                            (
                                free
                            )
                            (
                                x
                            )
                            !!
                            (
                                free
                            )
                            (
                                y
                            )
                        )
                      )
                      case
                      (
                        Neg
                          x
                        !!
                        (
                            free
                        )
                        (
                            x
                        )
                      )
                      case
                      (
                        Mult
                          (
                            x
                            y
                          )
                        Names.union
                        (
                            !!
                            (
                                free
                            )
                            (
                                x
                            )
                            !!
                            (
                                free
                            )
                            (
                                y
                            )
                        )
                      )
                    )
                                      method map
                    (
                      case
                      (
                        f
                        (
                          case
                          (
                            alias x
                            (
                              pat_type                              var
                            )
                            x
                          )
                          case
                          (
                            alias x
                            (
                              Num
                                _
                            )
                            x
                          )
                          case
                          (
                            alias e
                            (
                              Add
                                (
                                  x
                                  y
                                )
                            )
                            let
                            (
                              (
                                x'
                                  f
                                  (
                                      x
                                  )
                                y'
                                  f
                                  (
                                      y
                                  )
                              )
                            in
                              ifthenelse
                              (
                                if
                                (
                                  &&
                                  (
                                      ==
                                      (
                                          x
                                          x'
                                      )
                                      ==
                                      (
                                          y
                                          y'
                                      )
                                  )
                                )
                                then
                                (
                                  e
                                )
                                else
                                (
                                    Add
                                      (
                                        x'
                                        y'
                                      )
                                )
                              )
                            )
                          )
                          case
                          (
                            alias e
                            (
                              Neg
                                x
                            )
                            let
                            (
                              (
                                x'
                                  f
                                  (
                                      x
                                  )
                              )
                            in
                              ifthenelse
                              (
                                if
                                (
                                  ==
                                  (
                                      x
                                      x'
                                  )
                                )
                                then
                                (
                                  e
                                )
                                else
                                (
                                    Neg
                                      x'
                                )
                              )
                            )
                          )
                          case
                          (
                            alias e
                            (
                              Mult
                                (
                                  x
                                  y
                                )
                            )
                            let
                            (
                              (
                                x'
                                  f
                                  (
                                      x
                                  )
                                y'
                                  f
                                  (
                                      y
                                  )
                              )
                            in
                              ifthenelse
                              (
                                if
                                (
                                  &&
                                  (
                                      ==
                                      (
                                          x
                                          x'
                                      )
                                      ==
                                      (
                                          y
                                          y'
                                      )
                                  )
                                )
                                then
                                (
                                  e
                                )
                                else
                                (
                                    Mult
                                      (
                                        x'
                                        y'
                                      )
                                )
                              )
                            )
                          )
                        )
                      )
                    )
                                      method subst
                    (
                      case
                      (
                        sub
                        (
                          case
                          (
                            alias x
                            (
                              pat_type                              var
                            )
                            send subst
                            (
                              var
                            )
                            (
                                sub
                                x
                            )
                          )
                          case
                          (
                            alias e
                            (
                              pat_type                              expr
                            )
                            send map
                            (
                              self
                            )
                            (
                                !!
                                (
                                    subst
                                )
                                (
                                    sub
                                )
                                e
                            )
                          )
                        )
                      )
                    )
                                      method eval
                    (
                      case
                      (
                        alias e
                        (
                          pat_type                          expr
                        )
                        match
                        send map
                        (
                          self
                        )
                        (
                            !!
                            (
                                eval
                            )
                            e
                        )
                        (
                          case
                          (
                            Add
                              (
                                Num
                                  m
                                Num
                                  n
                              )
                            Num
                              +
                              (
                                  m
                                  n
                              )
                          )
                          case
                          (
                            Neg
                              Num
                                n
                            Num
                              ~-
                              (
                                  n
                              )
                          )
                          case
                          (
                            Mult
                              (
                                Num
                                  m
                                Num
                                  n
                              )
                            Num
                              *
                              (
                                  m
                                  n
                              )
                          )
                          case
                          (
                            e
                            e
                          )
                        )
                      )
                    )
                                    )
  )
  let
  (
    expr
      lazy_fix
      (
          new expr_ops
      )
  )
  type
  (
    lexpr
      type
        params =
          (
            a
          )
        cstrs =
          (
          )
        kind =
              Ptyp_variant closed=true
              (
                Rinherit
                     lambda
                    (
                        a
                    )
                Rinherit
                     expr
                    (
                        a
                    )
              )
                )
  class
  (
      params =
          (
            "a"
          )
      class name = lexpr_ops
      class expr =
                    ops
             Lazy.t
            (
                ops
                (
                    a
                    a
                )
            )
            let
            (
              lambda
                new lambda_ops
                (
                    ops
                )
            )
              let
              (
                expr
                  new expr_ops
                  (
                      ops
                  )
              )
                class_structure
                  (
                    Pcf_constr ([159,4589+4]..[159,4589+32])
                        a
                        Ptyp_variant closed=false
                        (
                          Rinherit
                               lexpr
                              (
                                  a
                              )
                        )
                                            method free
                      (
                        case
                        (
                          alias x
                          (
                            pat_type                            lambda
                          )
                          send free
                          (
                            lambda
                          )
                          (
                              x
                          )
                        )
                        case
                        (
                          alias x
                          (
                            pat_type                            expr
                          )
                          send free
                          (
                            expr
                          )
                          (
                              x
                          )
                        )
                      )
                                          method subst
                      (
                        case
                        (
                          sub
                          (
                            case
                            (
                              alias x
                              (
                                pat_type                                lambda
                              )
                              send subst
                              (
                                lambda
                              )
                              (
                                  sub
                                  x
                              )
                            )
                            case
                            (
                              alias x
                              (
                                pat_type                                expr
                              )
                              send subst
                              (
                                expr
                              )
                              (
                                  sub
                                  x
                              )
                            )
                          )
                        )
                      )
                                          method eval
                      (
                        case
                        (
                          alias x
                          (
                            pat_type                            lambda
                          )
                          send eval
                          (
                            lambda
                          )
                          (
                              x
                          )
                        )
                        case
                        (
                          alias x
                          (
                            pat_type                            expr
                          )
                          send eval
                          (
                            expr
                          )
                          (
                              x
                          )
                        )
                      )
                                        )
  )
  let
  (
    lexpr
      lazy_fix
      (
          new lexpr_ops
      )
  )
  let
  (
    print
      (
        case
        (
          Var
            id
          print_string
          (
              id
          )
        )
        case
        (
          Abs
            (
              id
              l
            )
          sequence
          (
            print_string
            (
                ^
                (
                    " "
                    ^
                    (
                        id
                        " . "
                    )
                )
            )
          ;
            print
            (
                l
            )
          )
        )
        case
        (
          App
            (
              l1
              l2
            )
          sequence
          (
            print
            (
                l1
            )
          ;
            sequence
            (
              print_string
              (
                  " "
              )
            ;
              print
              (
                  l2
              )
            )
          )
        )
        case
        (
          Num
            x
          print_int
          (
              x
          )
        )
        case
        (
          Add
            (
              e1
              e2
            )
          sequence
          (
            print
            (
                e1
            )
          ;
            sequence
            (
              print_string
              (
                  " + "
              )
            ;
              print
              (
                  e2
              )
            )
          )
        )
        case
        (
          Neg
            e
          sequence
          (
            print_string
            (
                "-"
            )
          ;
            print
            (
                e
            )
          )
        )
        case
        (
          Mult
            (
              e1
              e2
            )
          sequence
          (
            print
            (
                e1
            )
          ;
            sequence
            (
              print_string
              (
                  " * "
              )
            ;
              print
              (
                  e2
              )
            )
          )
        )
      )
  )
  let
  (
    ()
          let
      (
        (
          e1
            send eval
            (
              lambda
            )
            (
                App
                  (
                    Abs
                      (
                        "x"
                        Var
                          "x"
                      )
                    Var
                      "y"
                  )
            )
        )
      in
        let
        (
          (
            e2
              send eval
              (
                expr
              )
              (
                  Add
                    (
                      Mult
                        (
                          Num
                            3
                          Neg
                            Num
                              2
                        )
                      Var
                        "x"
                    )
              )
          )
        in
          let
          (
            (
              e3
                send eval
                (
                  lexpr
                )
                (
                    Add
                      (
                        App
                          (
                            Abs
                              (
                                "x"
                                Mult
                                  (
                                    Var
                                      "x"
                                    Var
                                      "x"
                                  )
                              )
                            Num
                              2
                          )
                        Num
                          5
                      )
                )
            )
          in
            sequence
            (
              print
              (
                  e1
              )
            ;
              sequence
              (
                print_newline
                (
                    ()
                                    )
              ;
                sequence
                (
                  print
                  (
                      e2
                  )
                ;
                  sequence
                  (
                    print_newline
                    (
                        ()
                                            )
                  ;
                    sequence
                    (
                      print
                      (
                          e3
                      )
                    ;
                      print_newline
                      (
                          ()
                                                )
                    )
                  )
                )
              )
            )
          )
        )
      )
  )
)
