(
  open StdLabels
  open MoreLabels
  module Subst
      Map.Make
    (
      struct
      (
        type
        (
          t
            type
              params =
                (
                )
              cstrs =
                (
                )
              kind =
                
                     string
                    (
                    )
        )
        let
        (
          compare
            compare
        )
      )
    )
  module Names
      Set.Make
    (
      struct
      (
        type
        (
          t
            type
              params =
                (
                )
              cstrs =
                (
                )
              kind =
                
                     string
                    (
                    )
        )
        let
        (
          compare
            compare
        )
      )
    )
  type
  (
    var
      type
        params =
          (
          )
        cstrs =
          (
          )
        kind =
          
              Ptyp_variant closed=true
              (
                Rtag "Var" false
                  (
                       string
                      (
                      )
                  )
              )
                )
  let
  (
    subst_var
      (
        case
        (
          subst
          (
          (
            case
            (
              alias x
              (
                Var
                  s
              )
              try
              Subst.find
              (
                  s
                  subst
              )
              (
                case
                (
                  Not_found
                                    x
                )
              )
            )
          )
          :
              arrow
              
                 var
                (
                )
                
                    )
        )
      )
  )
  let
  (
    free_var
      (
      (
        case
        (
          Var
            s
          Names.singleton
          (
              s
          )
        )
      )
      :
          arrow
          
             var
            (
            )
            
            )
  )
  type
  (
    lambda
      type
        params =
          (
            a
          )
        cstrs =
          (
          )
        kind =
          
              Ptyp_variant closed=true
              (
                Rtag "Var" false
                  (
                       string
                      (
                      )
                  )
                Rtag "Abs" false
                  (
                      tuple
                      (
                           string
                          (
                          )
                          a
                      )
                  )
                Rtag "App" false
                  (
                      tuple
                      (
                          a
                          a
                      )
                  )
              )
                )
  let
  (
    free_lambda
      (
        case
        (
          free_rec
          (
          (
            case
            (
              alias x
              (
                pat_type                var
              )
              free_var
              (
                  x
              )
            )
            case
            (
              Abs
                (
                  s
                  t
                )
              Names.remove
              (
                  s
                  free_rec
                  (
                      t
                  )
              )
            )
            case
            (
              App
                (
                  t1
                  t2
                )
              Names.union
              (
                  free_rec
                  (
                      t1
                  )
                  free_rec
                  (
                      t2
                  )
              )
            )
          )
          :
              arrow
              
                 lambda
                (
                    
                )
                
                    )
        )
      )
  )
  let
  (
    map_lambda
      (
        case
        (
          map_rec
          (
          (
            case
            (
              alias x
              (
                pat_type                var
              )
              x
            )
            case
            (
              alias l
              (
                Abs
                  (
                    s
                    t
                  )
              )
              let
              (
                (
                  t'
                    map_rec
                    (
                        t
                    )
                )
              in
                ifthenelse
                (
                  if
                  (
                    ==
                    (
                        t
                        t'
                    )
                  )
                  then
                  (
                    l
                  )
                  else
                  (
                      Abs
                        (
                          s
                          t'
                        )
                  )
                )
              )
            )
            case
            (
              alias l
              (
                App
                  (
                    t1
                    t2
                  )
              )
              let
              (
                (
                  t'1
                    map_rec
                    (
                        t1
                    )
                  t'2
                    map_rec
                    (
                        t2
                    )
                )
              in
                ifthenelse
                (
                  if
                  (
                    &&
                    (
                        ==
                        (
                            t'1
                            t1
                        )
                        ==
                        (
                            t'2
                            t2
                        )
                    )
                  )
                  then
                  (
                    l
                  )
                  else
                  (
                      App
                        (
                          t'1
                          t'2
                        )
                  )
                )
              )
            )
          )
          :
              arrow
              
                 lambda
                (
                    
                )
                
                    )
        )
      )
  )
  let
  (
    next_id
      let
      (
        (
          current
            ref
            (
                3
            )
        )
      in
        (
          case
          (
            ()
                        sequence
            (
              incr
              (
                  current
              )
            ;
              !
              (
                  current
              )
            )
          )
        )
      )
  )
  let
  (
    subst_lambda
      (
        case
        (
          subst_rec
          (
            case
            (
              free
              (
                case
                (
                  subst
                  (
                  (
                    case
                    (
                      alias x
                      (
                        pat_type                        var
                      )
                      subst_var
                      (
                          subst
                          x
                      )
                    )
                    case
                    (
                      alias l
                      (
                        Abs
                          (
                            s
                            t
                          )
                      )
                      let
                      (
                        (
                          used
                            free
                            (
                                t
                            )
                        )
                      in
                        let
                        (
                          (
                            used_expr
                              Subst.fold
                              (
                                  subst
                                  []
                                                                    (
                                    case
                                    (
                                      key
                                      (
                                        case
                                        (
                                          data
                                          (
                                            case
                                            (
                                              acc
                                              ifthenelse
                                              (
                                                if
                                                (
                                                  Names.mem
                                                  (
                                                      s
                                                      used
                                                  )
                                                )
                                                then
                                                (
                                                  ::
                                                    (
                                                      data
                                                      acc
                                                    )
                                                )
                                                else
                                                (
                                                    acc
                                                )
                                              )
                                            )
                                          )
                                        )
                                      )
                                    )
                                  )
                              )
                          )
                        in
                          ifthenelse
                          (
                            if
                            (
                              List.exists
                              (
                                  used_expr
                                  (
                                    case
                                    (
                                      t
                                      Names.mem
                                      (
                                          s
                                          free
                                          (
                                              t
                                          )
                                      )
                                    )
                                  )
                              )
                            )
                            then
                            (
                              let
                              (
                                (
                                  name
                                    ^
                                    (
                                        s
                                        string_of_int
                                        (
                                            next_id
                                            (
                                                ()
                                                                                            )
                                        )
                                    )
                                )
                              in
                                Abs
                                  (
                                    name
                                    subst_rec
                                    (
                                        Subst.add
                                        (
                                            s
                                            Var
                                              name
                                            subst
                                        )
                                        t
                                    )
                                  )
                              )
                            )
                            else
                            (
                                map_lambda
                                (
                                    subst_rec
                                    (
                                        Subst.remove
                                        (
                                            s
                                            subst
                                        )
                                    )
                                    l
                                )
                            )
                          )
                        )
                      )
                    )
                    case
                    (
                      alias l
                      (
                        App
                          _
                      )
                      map_lambda
                      (
                          subst_rec
                          (
                              subst
                          )
                          l
                      )
                    )
                  )
                  :
                      arrow
                      
                         lambda
                        (
                            
                        )
                        
                                    )
                )
              )
            )
          )
        )
      )
  )
  let
  (
    eval_lambda
      (
        case
        (
          eval_rec
          (
            case
            (
              subst
              (
                case
                (
                  l
                  match
                  map_lambda
                  (
                      eval_rec
                      l
                  )
                  (
                    case
                    (
                      App
                        (
                          Abs
                            (
                              s
                              t1
                            )
                          t2
                        )
                      eval_rec
                      (
                          subst
                          (
                              Subst.add
                              (
                                  s
                                  t2
                                  Subst.empty
                              )
                              t1
                          )
                      )
                    )
                    case
                    (
                      t
                      t
                    )
                  )
                )
              )
            )
          )
        )
      )
  )
  let
  (
    free1
      (
        case
        (
          x
          free_lambda
          (
              free1
              x
          )
        )
      )
  )
  let
  (
    subst1
      (
        case
        (
          subst
          subst_lambda
          (
              subst1
              free1
              subst
          )
        )
      )
  )
  let
  (
    eval1
      (
        case
        (
          x
          eval_lambda
          (
              eval1
              subst1
              x
          )
        )
      )
  )
  type
  (
    expr
      type
        params =
          (
            a
          )
        cstrs =
          (
          )
        kind =
          
              Ptyp_variant closed=true
              (
                Rtag "Var" false
                  (
                       string
                      (
                      )
                  )
                Rtag "Num" false
                  (
                       int
                      (
                      )
                  )
                Rtag "Add" false
                  (
                      tuple
                      (
                          a
                          a
                      )
                  )
                Rtag "Neg" false
                  (
                      a
                  )
                Rtag "Mult" false
                  (
                      tuple
                      (
                          a
                          a
                      )
                  )
              )
                )
  let
  (
    free_expr
      (
        case
        (
          free_rec
          (
          (
            case
            (
              alias x
              (
                pat_type                var
              )
              free_var
              (
                  x
              )
            )
            case
            (
              Num
                _
              Names.empty
            )
            case
            (
              Add
                (
                  x
                  y
                )
              Names.union
              (
                  free_rec
                  (
                      x
                  )
                  free_rec
                  (
                      y
                  )
              )
            )
            case
            (
              Neg
                x
              free_rec
              (
                  x
              )
            )
            case
            (
              Mult
                (
                  x
                  y
                )
              Names.union
              (
                  free_rec
                  (
                      x
                  )
                  free_rec
                  (
                      y
                  )
              )
            )
          )
          :
              arrow
              
                 expr
                (
                    
                )
                
                    )
        )
      )
  )
  let
  (
    map_expr
      (
        case
        (
          map_rec
          (
          (
            case
            (
              alias x
              (
                pat_type                var
              )
              x
            )
            case
            (
              alias x
              (
                Num
                  _
              )
              x
            )
            case
            (
              alias e
              (
                Add
                  (
                    x
                    y
                  )
              )
              let
              (
                (
                  x'
                    map_rec
                    (
                        x
                    )
                  y'
                    map_rec
                    (
                        y
                    )
                )
              in
                ifthenelse
                (
                  if
                  (
                    &&
                    (
                        ==
                        (
                            x
                            x'
                        )
                        ==
                        (
                            y
                            y'
                        )
                    )
                  )
                  then
                  (
                    e
                  )
                  else
                  (
                      Add
                        (
                          x'
                          y'
                        )
                  )
                )
              )
            )
            case
            (
              alias e
              (
                Neg
                  x
              )
              let
              (
                (
                  x'
                    map_rec
                    (
                        x
                    )
                )
              in
                ifthenelse
                (
                  if
                  (
                    ==
                    (
                        x
                        x'
                    )
                  )
                  then
                  (
                    e
                  )
                  else
                  (
                      Neg
                        x'
                  )
                )
              )
            )
            case
            (
              alias e
              (
                Mult
                  (
                    x
                    y
                  )
              )
              let
              (
                (
                  x'
                    map_rec
                    (
                        x
                    )
                  y'
                    map_rec
                    (
                        y
                    )
                )
              in
                ifthenelse
                (
                  if
                  (
                    &&
                    (
                        ==
                        (
                            x
                            x'
                        )
                        ==
                        (
                            y
                            y'
                        )
                    )
                  )
                  then
                  (
                    e
                  )
                  else
                  (
                      Mult
                        (
                          x'
                          y'
                        )
                  )
                )
              )
            )
          )
          :
              arrow
              
                 expr
                (
                    
                )
                
                    )
        )
      )
  )
  let
  (
    subst_expr
      (
        case
        (
          subst_rec
          (
            case
            (
              subst
              (
              (
                case
                (
                  alias x
                  (
                    pat_type                    var
                  )
                  subst_var
                  (
                      subst
                      x
                  )
                )
                case
                (
                  alias e
                  (
                    pat_type                    expr
                  )
                  map_expr
                  (
                      subst_rec
                      (
                          subst
                      )
                      e
                  )
                )
              )
              :
                  arrow
                  
                     expr
                    (
                        
                    )
                    
                            )
            )
          )
        )
      )
  )
  let
  (
    eval_expr
      (
        case
        (
          eval_rec
          (
            case
            (
              e
              match
              map_expr
              (
                  eval_rec
                  e
              )
              (
                case
                (
                  Add
                    (
                      Num
                        m
                      Num
                        n
                    )
                  Num
                    +
                    (
                        m
                        n
                    )
                )
                case
                (
                  Neg
                    Num
                      n
                  Num
                    ~-
                    (
                        n
                    )
                )
                case
                (
                  Mult
                    (
                      Num
                        m
                      Num
                        n
                    )
                  Num
                    *
                    (
                        m
                        n
                    )
                )
                case
                (
                  alias e
                  (
                    pat_type                    expr
                  )
                  e
                )
              )
            )
          )
        )
      )
  )
  let
  (
    free2
      (
        case
        (
          x
          free_expr
          (
              free2
              x
          )
        )
      )
  )
  let
  (
    subst2
      (
        case
        (
          subst
          subst_expr
          (
              subst2
              subst
          )
        )
      )
  )
  let
  (
    eval2
      (
        case
        (
          x
          eval_expr
          (
              eval2
              x
          )
        )
      )
  )
  type
  (
    lexpr
      type
        params =
          (
          )
        cstrs =
          (
          )
        kind =
          
              Ptyp_variant closed=true
              (
                Rtag "Var" false
                  (
                       string
                      (
                      )
                  )
                Rtag "Abs" false
                  (
                      tuple
                      (
                           string
                          (
                          )
                           lexpr
                          (
                          )
                      )
                  )
                Rtag "App" false
                  (
                      tuple
                      (
                           lexpr
                          (
                          )
                           lexpr
                          (
                          )
                      )
                  )
                Rtag "Num" false
                  (
                       int
                      (
                      )
                  )
                Rtag "Add" false
                  (
                      tuple
                      (
                           lexpr
                          (
                          )
                           lexpr
                          (
                          )
                      )
                  )
                Rtag "Neg" false
                  (
                       lexpr
                      (
                      )
                  )
                Rtag "Mult" false
                  (
                      tuple
                      (
                           lexpr
                          (
                          )
                           lexpr
                          (
                          )
                      )
                  )
              )
                )
  let
  (
    free
      (
      (
        case
        (
          alias x
          (
            pat_type            lambda
          )
          free_lambda
          (
              free
              x
          )
        )
        case
        (
          alias x
          (
            pat_type            expr
          )
          free_expr
          (
              free
              x
          )
        )
      )
      :
          arrow
          
             lexpr
            (
            )
            
            )
  )
  let
  (
    subst
      (
        case
        (
          s
          (
          (
            case
            (
              alias x
              (
                pat_type                lambda
              )
              subst_lambda
              (
                  subst
                  s
                  free
                  x
              )
            )
            case
            (
              alias x
              (
                pat_type                expr
              )
              subst_expr
              (
                  subst
                  s
                  x
              )
            )
          )
          :
              arrow
              
                 lexpr
                (
                )
                
                    )
        )
      )
  )
  let
  (
    eval
      (
      (
        case
        (
          alias x
          (
            pat_type            lambda
          )
          eval_lambda
          (
              eval
              subst
              x
          )
        )
        case
        (
          alias x
          (
            pat_type            expr
          )
          eval_expr
          (
              eval
              x
          )
        )
      )
      :
          arrow
          
             lexpr
            (
            )
            
            )
  )
  let
  (
    print
      (
        case
        (
          Var
            id
          print_string
          (
              id
          )
        )
        case
        (
          Abs
            (
              id
              l
            )
          sequence
          (
            print_string
            (
                ^
                (
                    " "
                    ^
                    (
                        id
                        " . "
                    )
                )
            )
          ;
            print
            (
                l
            )
          )
        )
        case
        (
          App
            (
              l1
              l2
            )
          sequence
          (
            print
            (
                l1
            )
          ;
            sequence
            (
              print_string
              (
                  " "
              )
            ;
              print
              (
                  l2
              )
            )
          )
        )
        case
        (
          Num
            x
          print_int
          (
              x
          )
        )
        case
        (
          Add
            (
              e1
              e2
            )
          sequence
          (
            print
            (
                e1
            )
          ;
            sequence
            (
              print_string
              (
                  " + "
              )
            ;
              print
              (
                  e2
              )
            )
          )
        )
        case
        (
          Neg
            e
          sequence
          (
            print_string
            (
                "-"
            )
          ;
            print
            (
                e
            )
          )
        )
        case
        (
          Mult
            (
              e1
              e2
            )
          sequence
          (
            print
            (
                e1
            )
          ;
            sequence
            (
              print_string
              (
                  " * "
              )
            ;
              print
              (
                  e2
              )
            )
          )
        )
      )
  )
  let
  (
    ()
          let
      (
        (
          e1
            eval1
            (
                App
                  (
                    Abs
                      (
                        "x"
                        Var
                          "x"
                      )
                    Var
                      "y"
                  )
            )
        )
      in
        let
        (
          (
            e2
              eval2
              (
                  Add
                    (
                      Mult
                        (
                          Num
                            3
                          Neg
                            Num
                              2
                        )
                      Var
                        "x"
                    )
              )
          )
        in
          let
          (
            (
              e3
                eval
                (
                    Add
                      (
                        App
                          (
                            Abs
                              (
                                "x"
                                Mult
                                  (
                                    Var
                                      "x"
                                    Var
                                      "x"
                                  )
                              )
                            Num
                              2
                          )
                        Num
                          5
                      )
                )
            )
          in
            sequence
            (
              print
              (
                  e1
              )
            ;
              sequence
              (
                print_newline
                (
                    ()
                                    )
              ;
                sequence
                (
                  print
                  (
                      e2
                  )
                ;
                  sequence
                  (
                    print_newline
                    (
                        ()
                                            )
                  ;
                    sequence
                    (
                      print
                      (
                          e3
                      )
                    ;
                      print_newline
                      (
                          ()
                                                )
                    )
                  )
                )
              )
            )
          )
        )
      )
  )
)

