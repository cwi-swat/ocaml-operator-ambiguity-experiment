(
  open StdLabels
  open MoreLabels
  module  Subst
       							      Map.Make
   (
   struct
   (
   type
   (  						
      t
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
         string
         (
         )
   )
   let
   (
     compare
     compare 
   )
   )
   )
  module  Names
       							      Set.Make
   (
   struct
   (
   type
   (  						
      t
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
         string
         (
         )
   )
   let
   (
     compare
     compare 
   )
   )
   )
  let
  (
    lazy_fix
   (
    case
        (
    	  make
         let
         (
          (
            obj
           (
            case
                (
            	  ()
                 make
                 (
                     (
                     lazy
                       obj
                       (
                           ()
                       )
                     :
                      Lazy.t
                      (
                        <>
                      )
                     )
                 )
                )
           )
          )
         in
           obj
           (
               ()
           )
         )
        )
   )
  )
  let
  (
    !!
    Lazy.force 
  )
  class_type
  (
    class_type_declaration
    params = 
    (
     "ab"
    ) 
    name = ops
    expr =
     class_type
     signature
     class_signature
     (
      poly
      arrow
      b
      Names.t
      (
      )
      poly
      arrow2 
      (
          sub
           Subst.t
           (
             a
           )
          arrow
          b
          a
      )
      poly
      arrow
      b
      a
     )
  )
  type
  (  						
     var
       type
       params=
       (
       )
       cstrs =
       (
       )
       kind =
        <[],[<"Var",["typexprConstr2"("typeConstr"([],"string")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>]>
  )
  class
  (
    params = 
    (
     "a"
    )
    class name = var_ops
    class expr = 
      class_structure
      (
         classConstraint 
         (
             a
             var
             (
             )
         )
         method subst
         (
           case
         	(
         		sub
         		alias x
         		(
         		  Var
         		  s
         		)
           	try
           	Subst.find
           	(
           	    s
           	    sub
           	)
           	(
           	case
           	(
           	  Not_found
           	  x
           	) 
           	)
         	)
         )
         method free
         (
           case
         	(
         		Var
         		s
           	Names.singleton
           	(
           	    s
           	)
         	)
         )
         method eval
         (
           case
         	(
         		alias v
         		(
         		  var
         		)
           	v
         	)
         )
      )
  )
  type
  (  						
     lambda
       type
       params=
       (
        a
       )
       cstrs =
       (
       )
       kind =
        <[],[<"Var",["typexprConstr2"("typeConstr"([],"string")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>,<"Abs",["star"("typexprConstr2"("typeConstr"([],"string")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],["tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>,<"App",["star"("tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],["tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>]>
  )
  let
  (
    next_id
    let
    (
     (
       current
       ref
       (
           3
       ) 
     )
    in
      (
       case
       (
       ()
       sequence
       (
         incr
         (
             current
         )
       ;
          !
          (
          current
          )
       )
       )
      )
    )
  )
  class
  (
    params = 
    (
     "a"
    )
    class name = lambda_ops
    class expr = 
      ops
       Lazy.t
       (
         <["tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],"classPath"([],"ops")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
       )
      let
      (
        var
        (
         new var_ops 
         :
          var_ops
          (
            a
          )
        )
        free
        lazy
          send free
          (
            !!
            (
            ops
            )
          )
        subst
        lazy
          send subst
          (
            !!
            (
            ops
            )
          )
        eval
        lazy
          send eval
          (
            !!
            (
            ops
            )
          )
      )
       class_structure
       (
          classConstraint 
          (
              a
               lambda
               (
                 a
               )
          )
          method free
          	  (
          	   case
          	   (
          	     alias x
          	     (
          	       var
          	     )
          	     send free
          	     (
          	      var
          	     )
          	     (
          	         x
          	     )
          	   ) 
          	     case
          	     (
          	      Abs
          	      (
          	       s
          	      	t
          	      )
          	      Names.remove
          	      (
          	          s
          	           !!
          	           (
          	           free
          	           )
          	          (
          	              t
          	          )
          	      )
          	     )
          	     case
          	     (
          	      App
          	      (
          	       t1
          	      	t2
          	      )
          	      Names.union
          	      (
          	           !!
          	           (
          	           free
          	           )
          	          (
          	              t1
          	          )
          	           !!
          	           (
          	           free
          	           )
          	          (
          	              t2
          	          )
          	      )
          	     )
          	  )
          method map
          (
            case
          	(
          		f
            	(
            	 case
            	 (
            	   alias x
            	   (
            	     var
            	   )
            	   x
            	 ) 
            	   case
            	   (
            	    alias l
            	    (
            	      Abs
            	      (
            	       s
            	      	t
            	      )
            	    )
            	    let
            	    (
            	     (
            	       t'
            	       f
            	       (
            	           t
            	       ) 
            	     )
            	    in
            	      ifthenelse
            	      (
            	       if
            	       (
            	        ==
            	        (
            	            t
            	            t'
            	        )
            	       )
            	       then
            	       (
            	        l
            	       )
            	       else
            	       (
            	        Abs
            	           (
            	            s
            	           	t'
            	           )
            	       ) 
            	      )
            	    )
            	   )
            	   case
            	   (
            	    alias l
            	    (
            	      App
            	      (
            	       t1
            	      	t2
            	      )
            	    )
            	    let
            	    (
            	     (
            	       t'1
            	       f
            	       (
            	           t1
            	       ) 
            	       t'2
            	       f
            	       (
            	           t2
            	       ) 
            	     )
            	    in
            	      ifthenelse
            	      (
            	       if
            	       (
            	        &&
            	        (
            	            ==
            	            (
            	                t'1
            	                t1
            	            )
            	            ==
            	            (
            	                t'2
            	                t2
            	            )
            	        )
            	       )
            	       then
            	       (
            	        l
            	       )
            	       else
            	       (
            	        App
            	           (
            	            t'1
            	           	t'2
            	           )
            	       ) 
            	      )
            	    )
            	   )
            	)
          	)
          )
          method subst
          (
            case
          	(
          		sub
            	(
            	 case
            	 (
            	   alias x
            	   (
            	     var
            	   )
            	   send subst
            	   (
            	    var
            	   )
            	   (
            	       sub
            	       x
            	   )
            	 ) 
            	   case
            	   (
            	    alias l
            	    (
            	      Abs
            	      (
            	       s
            	      	t
            	      )
            	    )
            	    let
            	    (
            	     (
            	       used
            	        !!
            	        (
            	        free
            	        )
            	       (
            	           t
            	       ) 
            	     )
            	    in
            	      let
            	      (
            	       (
            	         used_expr
            	         Subst.fold
            	         (
            	             sub
            	             <"~init:","constant"("emptyBrackets"()[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
            	             <"~f:","brackets"("fun"("multipleMatching"(["key","data","patternValueName"("acc")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],[],"ifThenElse"("functionApplication"("valuePath"("valuePath"(["modulePath"([],"Names")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],"mem")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],["valuePath"("valuePath"([],"s")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"valuePath"("valuePath"([],"used")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"coloncolon"("valuePath"("valuePath"([],"data")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"valuePath"("valuePath"([],"acc")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"valuePath"("valuePath"([],"acc")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
            	         ) 
            	       )
            	      in
            	        ifthenelse
            	        (
            	         if
            	         (
            	          List.exists
            	          (
            	              used_expr
            	              <"~f:","brackets"("fun"("multipleMatching"(["patternValueName"("t")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],[],"functionApplication"("valuePath"("valuePath"(["modulePath"([],"Names")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],"mem")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],["valuePath"("valuePath"([],"s")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"brackets"("functionApplication"("prefix"("!!","valuePath"("valuePath"([],"free")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],["valuePath"("valuePath"([],"t")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
            	          )
            	         )
            	         then
            	         (
            	          let
            	          (
            	           (
            	             name
            	             ^
            	             (
            	                 s
            	                 string_of_int
            	                 (
            	                     next_id
            	                     (
            	                         ()
            	                     )
            	                 )
            	             ) 
            	           )
            	          in
            	            Abs
            	               (
            	                name
            	               	 !!
            	               	 (
            	               	 subst
            	               	 )
            	               	(
            	               	    <"~sub:","brackets"("functionApplication"("valuePath"("valuePath"(["modulePath"([],"Subst")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],"add")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],[<"~key:","valuePath"("valuePath"([],"s")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>,<"~data:","brackets"("polyVariant"("Var","valuePath"("valuePath"([],"name")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>,"valuePath"("valuePath"([],"sub")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
            	               	    t
            	               	)
            	               )
            	          )
            	         )
            	         else
            	         (
            	          send map
            	          (
            	           self
            	          )
            	          (
            	              <"~f:","brackets"("functionApplication"("prefix"("!!","valuePath"("valuePath"([],"subst")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],[<"~sub:","brackets"("functionApplication"("valuePath"("valuePath"(["modulePath"([],"Subst")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],"remove")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],["valuePath"("valuePath"([],"s")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"valuePath"("valuePath"([],"sub")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
            	              l
            	          )
            	         ) 
            	        )
            	      )
            	    )
            	   )
            	   case
            	   (
            	    alias l
            	    (
            	      App
            	      _
            	    )
            	    send map
            	    (
            	     self
            	    )
            	    (
            	        <"~f:","brackets"("functionApplication"("prefix"("!!","valuePath"("valuePath"([],"subst")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],["sub"])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
            	        l
            	    )
            	   )
            	)
          	)
          )
          method eval
          (
            case
          	(
          		l
            	match
            	send map
            	(
            	 self
            	)
            	(
            	    <"~f:","prefix"("!!","valuePath"("valuePath"([],"eval")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
            	    l
            	)
            	(
            	case
            	(
            	  App
            	  (
            	   Abs
            	   (
            	    s
            	   	t1
            	   )
            	  	t2
            	  )
            	   !!
            	   (
            	   eval
            	   )
            	  (
            	       !!
            	       (
            	       subst
            	       )
            	      (
            	          <"~sub:","brackets"("functionApplication"("valuePath"("valuePath"(["modulePath"([],"Subst")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],"add")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],[<"~key:","valuePath"("valuePath"([],"s")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>,<"~data:","valuePath"("valuePath"([],"t2")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>,"valuePath"("valuePath"(["modulePath"([],"Subst")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],"empty")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
            	          t1
            	      )
            	  )
            	) 
            	  case
            	  (
            	   t
            	   t
            	  )
            	)
          	)
          )
       )
  )
  let
  (
    lambda
    lazy_fix
    (
        new lambda_ops
    ) 
  )
  type
  (  						
     expr
       type
       params=
       (
        a
       )
       cstrs =
       (
       )
       kind =
        <[],[<"Var",["typexprConstr2"("typeConstr"([],"string")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>,<"Num",["typexprConstr2"("typeConstr"([],"int")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>,<"Add",["star"("tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],["tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>,<"Neg",["tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>,<"Mult",["star"("tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],["tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>]>
  )
  class
  (
    params = 
    (
     "a"
    )
    class name = expr_ops
    class expr = 
      ops
       Lazy.t
       (
         <["tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],"classPath"([],"ops")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
       )
      let
      (
        var
        (
         new var_ops 
         :
          var_ops
          (
            a
          )
        )
        free
        lazy
          send free
          (
            !!
            (
            ops
            )
          )
        subst
        lazy
          send subst
          (
            !!
            (
            ops
            )
          )
        eval
        lazy
          send eval
          (
            !!
            (
            ops
            )
          )
      )
       class_structure
       (
          classConstraint 
          (
              a
               expr
               (
                 a
               )
          )
          method free
          	  (
          	   case
          	   (
          	     alias x
          	     (
          	       var
          	     )
          	     send free
          	     (
          	      var
          	     )
          	     (
          	         x
          	     )
          	   ) 
          	     case
          	     (
          	      Num
          	      _
          	      Names.empty
          	     )
          	     case
          	     (
          	      Add
          	      (
          	       x
          	      	y
          	      )
          	      Names.union
          	      (
          	           !!
          	           (
          	           free
          	           )
          	          (
          	              x
          	          )
          	           !!
          	           (
          	           free
          	           )
          	          (
          	              y
          	          )
          	      )
          	     )
          	     case
          	     (
          	      Neg
          	      x
          	       !!
          	       (
          	       free
          	       )
          	      (
          	          x
          	      )
          	     )
          	     case
          	     (
          	      Mult
          	      (
          	       x
          	      	y
          	      )
          	      Names.union
          	      (
          	           !!
          	           (
          	           free
          	           )
          	          (
          	              x
          	          )
          	           !!
          	           (
          	           free
          	           )
          	          (
          	              y
          	          )
          	      )
          	     )
          	  )
          method map
          (
            case
          	(
          		f
            	(
            	 case
            	 (
            	   alias x
            	   (
            	     var
            	   )
            	   x
            	 ) 
            	   case
            	   (
            	    alias x
            	    (
            	      Num
            	      _
            	    )
            	    x
            	   )
            	   case
            	   (
            	    alias e
            	    (
            	      Add
            	      (
            	       x
            	      	y
            	      )
            	    )
            	    let
            	    (
            	     (
            	       x'
            	       f
            	       (
            	           x
            	       ) 
            	       y'
            	       f
            	       (
            	           y
            	       ) 
            	     )
            	    in
            	      ifthenelse
            	      (
            	       if
            	       (
            	        &&
            	        (
            	            ==
            	            (
            	                x
            	                x'
            	            )
            	            ==
            	            (
            	                y
            	                y'
            	            )
            	        )
            	       )
            	       then
            	       (
            	        e
            	       )
            	       else
            	       (
            	        Add
            	           (
            	            x'
            	           	y'
            	           )
            	       ) 
            	      )
            	    )
            	   )
            	   case
            	   (
            	    alias e
            	    (
            	      Neg
            	      x
            	    )
            	    let
            	    (
            	     (
            	       x'
            	       f
            	       (
            	           x
            	       ) 
            	     )
            	    in
            	      ifthenelse
            	      (
            	       if
            	       (
            	        ==
            	        (
            	            x
            	            x'
            	        )
            	       )
            	       then
            	       (
            	        e
            	       )
            	       else
            	       (
            	        Neg
            	           x'
            	       ) 
            	      )
            	    )
            	   )
            	   case
            	   (
            	    alias e
            	    (
            	      Mult
            	      (
            	       x
            	      	y
            	      )
            	    )
            	    let
            	    (
            	     (
            	       x'
            	       f
            	       (
            	           x
            	       ) 
            	       y'
            	       f
            	       (
            	           y
            	       ) 
            	     )
            	    in
            	      ifthenelse
            	      (
            	       if
            	       (
            	        &&
            	        (
            	            ==
            	            (
            	                x
            	                x'
            	            )
            	            ==
            	            (
            	                y
            	                y'
            	            )
            	        )
            	       )
            	       then
            	       (
            	        e
            	       )
            	       else
            	       (
            	        Mult
            	           (
            	            x'
            	           	y'
            	           )
            	       ) 
            	      )
            	    )
            	   )
            	)
          	)
          )
          method subst
          (
            case
          	(
          		sub
            	(
            	 case
            	 (
            	   alias x
            	   (
            	     var
            	   )
            	   send subst
            	   (
            	    var
            	   )
            	   (
            	       sub
            	       x
            	   )
            	 ) 
            	   case
            	   (
            	    alias e
            	    (
            	      expr
            	    )
            	    send map
            	    (
            	     self
            	    )
            	    (
            	        <"~f:","brackets"("functionApplication"("prefix"("!!","valuePath"("valuePath"([],"subst")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],["sub"])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
            	        e
            	    )
            	   )
            	)
          	)
          )
          method eval
          (
            case
          	(
          		alias e
          		(
          		  expr
          		)
            	match
            	send map
            	(
            	 self
            	)
            	(
            	    <"~f:","prefix"("!!","valuePath"("valuePath"([],"eval")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
            	    e
            	)
            	(
            	case
            	(
            	  Add
            	  (
            	   Num
            	   m
            	  	Num
            	  	n
            	  )
            	  Num
            	     +
            	     (
            	         m
            	         n
            	     )
            	) 
            	  case
            	  (
            	   Neg
            	   Num
            	   n
            	   Num
            	      ~-
            	      (
            	       n
            	      )
            	  )
            	  case
            	  (
            	   Mult
            	   (
            	    Num
            	    m
            	   	Num
            	   	n
            	   )
            	   Num
            	      *
            	      (
            	          m
            	          n
            	      )
            	  )
            	  case
            	  (
            	   e
            	   e
            	  )
            	)
          	)
          )
       )
  )
  let
  (
    expr
    lazy_fix
    (
        new expr_ops
    ) 
  )
  type
  (  						
     lexpr
       type
       params=
       (
        a
       )
       cstrs =
       (
       )
       kind =
        <[],["typexprConstr1"("tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"typeConstr"([],"lambda")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"typexprConstr1"("tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"typeConstr"([],"expr")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>
  )
  class
  (
    params = 
    (
     "a"
    )
    class name = lexpr_ops
    class expr = 
      ops
       Lazy.t
       (
         <["tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],"classPath"([],"ops")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
       )
      let
      (
        lambda
        new lambda_ops
        (
            ops
        ) 
      )
       let
       (
         expr
         new expr_ops
         (
             ops
         ) 
       )
        class_structure
        (
           classConstraint 
           (
               a
                lexpr
                (
                  a
                )
           )
           method free
           	  (
           	   case
           	   (
           	     alias x
           	     (
           	       lambda
           	     )
           	     send free
           	     (
           	      lambda
           	     )
           	     (
           	         x
           	     )
           	   ) 
           	     case
           	     (
           	      alias x
           	      (
           	        expr
           	      )
           	      send free
           	      (
           	       expr
           	      )
           	      (
           	          x
           	      )
           	     )
           	  )
           method subst
           (
             case
           	(
           		sub
             	(
             	 case
             	 (
             	   alias x
             	   (
             	     lambda
             	   )
             	   send subst
             	   (
             	    lambda
             	   )
             	   (
             	       sub
             	       x
             	   )
             	 ) 
             	   case
             	   (
             	    alias x
             	    (
             	      expr
             	    )
             	    send subst
             	    (
             	     expr
             	    )
             	    (
             	        sub
             	        x
             	    )
             	   )
             	)
           	)
           )
           method eval
           	  (
           	   case
           	   (
           	     alias x
           	     (
           	       lambda
           	     )
           	     send eval
           	     (
           	      lambda
           	     )
           	     (
           	         x
           	     )
           	   ) 
           	     case
           	     (
           	      alias x
           	      (
           	        expr
           	      )
           	      send eval
           	      (
           	       expr
           	      )
           	      (
           	          x
           	      )
           	     )
           	  )
        )
  )
  let
  (
    lexpr
    lazy_fix
    (
        new lexpr_ops
    ) 
  )
  let
  (
    print
    (
     case
     (
       Var
       id
       print_string
       (
           id
       )
     ) 
       case
       (
        Abs
        (
         id
        	l
        )
        sequence
        (
          print_string
          (
              ^
              (
                  "\ "
                  ^
                  (
                      id
                      " . "
                  )
              )
          )
        ;
          print
          (
              l
          )
        )
       )
       case
       (
        App
        (
         l1
        	l2
        )
        sequence
        (
          print
          (
              l1
          )
        ;
          sequence
          (
            print_string
            (
                " "
            )
          ;
            print
            (
                l2
            )
          )
        )
       )
       case
       (
        Num
        x
        print_int
        (
            x
        )
       )
       case
       (
        Add
        (
         e1
        	e2
        )
        sequence
        (
          print
          (
              e1
          )
        ;
          sequence
          (
            print_string
            (
                " + "
            )
          ;
            print
            (
                e2
            )
          )
        )
       )
       case
       (
        Neg
        e
        sequence
        (
          print_string
          (
              "-"
          )
        ;
          print
          (
              e
          )
        )
       )
       case
       (
        Mult
        (
         e1
        	e2
        )
        sequence
        (
          print
          (
              e1
          )
        ;
          sequence
          (
            print_string
            (
                " * "
            )
          ;
            print
            (
                e2
            )
          )
        )
       )
    )
  )
  let
  (
    ()
    let
    (
     (
       e1
       send eval
       (
        lambda
       )
       (
           App
              (
               Abs
                  (
                   "x"
                  	Var
                  	   "x"
                  )
              	Var
              	   "y"
              )
       ) 
     )
    in
      let
      (
       (
         e2
         send eval
         (
          expr
         )
         (
             Add
                (
                 Mult
                    (
                     Num
                        3
                    	Neg
                    	   Num
                    	      2
                    )
                	Var
                	   "x"
                )
         ) 
       )
      in
        let
        (
         (
           e3
           send eval
           (
            lexpr
           )
           (
               Add
                  (
                   App
                      (
                       Abs
                          (
                           "x"
                          	Mult
                          	   (
                          	    Var
                          	       "x"
                          	   	Var
                          	   	   "x"
                          	   )
                          )
                      	Num
                      	   2
                      )
                  	Num
                  	   5
                  )
           ) 
         )
        in
          sequence
          (
            print
            (
                e1
            )
          ;
            sequence
            (
              print_newline
              (
                  ()
              )
            ;
              sequence
              (
                print
                (
                    e2
                )
              ;
                sequence
                (
                  print_newline
                  (
                      ()
                  )
                ;
                  sequence
                  (
                    print
                    (
                        e3
                    )
                  ;
                    print_newline
                    (
                        ()
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
)
