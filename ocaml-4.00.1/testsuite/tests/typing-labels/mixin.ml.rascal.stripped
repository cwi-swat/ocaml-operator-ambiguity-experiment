(
  open StdLabels
  open MoreLabels
  module  Subst
       							      Map.Make
   (
   struct
   (
   type
   (  						
      t
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        string
        (
        )
   )
   let
   (
     compare
     compare 
   )
   )
   )
  module  Names
       							      Set.Make
   (
   struct
   (
   type
   (  						
      t
        type
        params=
        (
        )
        cstrs =
        (
        )
        kind =
        string
        (
        )
   )
   let
   (
     compare
     compare 
   )
   )
   )
  type
  (  						
     var
       type
       params=
       (
       )
       cstrs =
       (
       )
       kind =
       (
       	  Var
       	  (
       	  	string
       	  	(
       	  	)
       	  )
       )
  )
  let
  (
    subst_var
   (
    case
        (
    	  subst
   	    (
         	 (
         	  case
         	  (
         	    alias x
         	    (
         	      Var
         	      s
         	    )
         	    try
         	    Subst.find
         	    (
         	        s
         	        subst
         	    )
         	    (
         	    case
         	    (
         	      Not_found
         	      x
         	    ) 
         	    )
         	  ) 
         	 )
            :
   		 arrow
   		 var
   		 (
   		 )
   		)
        )
   )
  )
  let
  (
    free_var
    (
     (
      case
      (
        Var
        s
        Names.singleton
        (
            s
        )
      ) 
     )
     :
     arrow
     var
     (
     )
    )
  )
  type
  (  						
     lambda
       type
       params=
       (
       a
       )
       cstrs =
       (
       )
       kind =
       (
       	  Var
       	  (
       	  	string
       	  	(
       	  	)
       	  )
       	  Abs
       	  (
       	  	tuple
       	  	(
       	  	 string
       	  	 (
       	  	 )
       	  	  a
       	  	)
       	  )
       	  App
       	  (
       	  	tuple
       	  	(
       	  	 a
       	  	  a
       	  	)
       	  )
       )
  )
  let
  (
    free_lambda
   (
    case
        (
    	  free_rec
   	    (
         	 (
         	  case
         	  (
         	    alias x
         	    (
         	      var
         	    )
         	    free_var
         	    (
         	        x
         	    )
         	  ) 
         	    case
         	    (
         	     Abs
         	     (
         	      s
         	     	t
         	     )
         	     Names.remove
         	     (
         	         s
         	         free_rec
         	         (
         	             t
         	         )
         	     )
         	    )
         	    case
         	    (
         	     App
         	     (
         	      t1
         	     	t2
         	     )
         	     Names.union
         	     (
         	         free_rec
         	         (
         	             t1
         	         )
         	         free_rec
         	         (
         	             t2
         	         )
         	     )
         	    )
         	 )
            :
   		 arrow
   		  lambda
   		  (
   		  )
   		)
        )
   )
  )
  let
  (
    map_lambda
   (
    case
        (
    	  map_rec
   	    (
         	 (
         	  case
         	  (
         	    alias x
         	    (
         	      var
         	    )
         	    x
         	  ) 
         	    case
         	    (
         	     alias l
         	     (
         	       Abs
         	       (
         	        s
         	       	t
         	       )
         	     )
         	     let
         	     (
         	      (
         	        t'
         	        map_rec
         	        (
         	            t
         	        ) 
         	      )
         	     in
         	       ifthenelse
         	       (
         	        if
         	        (
         	         ==
         	         (
         	             t
         	             t'
         	         )
         	        )
         	        then
         	        (
         	         l
         	        )
         	        else
         	        (
         	         Abs
         	            (
         	             s
         	            	t'
         	            )
         	        ) 
         	       )
         	     )
         	    )
         	    case
         	    (
         	     alias l
         	     (
         	       App
         	       (
         	        t1
         	       	t2
         	       )
         	     )
         	     let
         	     (
         	      (
         	        t'1
         	        map_rec
         	        (
         	            t1
         	        ) 
         	        t'2
         	        map_rec
         	        (
         	            t2
         	        ) 
         	      )
         	     in
         	       ifthenelse
         	       (
         	        if
         	        (
         	         &&
         	         (
         	             ==
         	             (
         	                 t'1
         	                 t1
         	             )
         	             ==
         	             (
         	                 t'2
         	                 t2
         	             )
         	         )
         	        )
         	        then
         	        (
         	         l
         	        )
         	        else
         	        (
         	         App
         	            (
         	             t'1
         	            	t'2
         	            )
         	        ) 
         	       )
         	     )
         	    )
         	 )
            :
   		 arrow
   		  lambda
   		  (
   		  )
   		)
        )
   )
  )
  let
  (
    next_id
    let
    (
     (
       current
       ref
       (
           3
       ) 
     )
    in
      (
        case
        (
         ()
         sequence
         (
           incr
           (
               current
           )
         ;
            !
            (
            current
            )
         )
        )
      )
    )
  )
  let
  (
     subst_lambda
   (
    case
        (
     		  subst_rec
     		(
     		 case
     		     (
     		  		 free
     		  		(
     		  		 case
     		  		     (
     		  		 	  subst
     		  			    (
     		  		      	 (
     		  		      	  case
     		  		      	  (
     		  		      	    alias x
     		  		      	    (
     		  		      	      var
     		  		      	    )
     		  		      	    subst_var
     		  		      	    (
     		  		      	        subst
     		  		      	        	subst
     		  		      	        x
     		  		      	    )
     		  		      	  ) 
     		  		      	    case
     		  		      	    (
     		  		      	     alias l
     		  		      	     (
     		  		      	       Abs
     		  		      	       (
     		  		      	        s
     		  		      	       	t
     		  		      	       )
     		  		      	     )
     		  		      	     let
     		  		      	     (
     		  		      	      (
     		  		      	        used
     		  		      	        free
     		  		      	        (
     		  		      	            t
     		  		      	        ) 
     		  		      	      )
     		  		      	     in
     		  		      	       let
     		  		      	       (
     		  		      	        (
     		  		      	          used_expr
     		  		      	          Subst.fold
     		  		      	          (
     		  		      	              subst
     		  		      	              init
     		  		      	              []
     		  		      	              f
     		  		      	              (
     		  		      	              case
     		  		      	                (
     		  		      	                  key
     		  		      	                  (
     		  		      	                  case
     		  		      	                    (
     		  		      	                      data
     		  		      	                      (
     		  		      	                        case
     		  		      	                        (
     		  		      	                         acc
     		  		      	                         ifthenelse
     		  		      	                         (
     		  		      	                          if
     		  		      	                          (
     		  		      	                           Names.mem
     		  		      	                           (
     		  		      	                               s
     		  		      	                               used
     		  		      	                           )
     		  		      	                          )
     		  		      	                          then
     		  		      	                          (
     		  		      	                           ::
     		  		      	                           (
     		  		      	                               data
     		  		      	                               acc
     		  		      	                           )
     		  		      	                          )
     		  		      	                          else
     		  		      	                          (
     		  		      	                           acc
     		  		      	                          ) 
     		  		      	                         )
     		  		      	                        )
     		  		      	                      )
     		  		      	                    )
     		  		      	                  )													
     		  		      	                )
     		  		      	              )													
     		  		      	          ) 
     		  		      	        )
     		  		      	       in
     		  		      	         ifthenelse
     		  		      	         (
     		  		      	          if
     		  		      	          (
     		  		      	           List.exists
     		  		      	           (
     		  		      	               used_expr
     		  		      	               f
     		  		      	               (
     		  		      	                 case
     		  		      	                 (
     		  		      	                  t
     		  		      	                  Names.mem
     		  		      	                  (
     		  		      	                      s
     		  		      	                      free
     		  		      	                      (
     		  		      	                          t
     		  		      	                      )
     		  		      	                  )
     		  		      	                 )
     		  		      	               )
     		  		      	           )
     		  		      	          )
     		  		      	          then
     		  		      	          (
     		  		      	           let
     		  		      	           (
     		  		      	            (
     		  		      	              name
     		  		      	              ^
     		  		      	              (
     		  		      	                  s
     		  		      	                  string_of_int
     		  		      	                  (
     		  		      	                      next_id
     		  		      	                      (
     		  		      	                          ()
     		  		      	                      )
     		  		      	                  )
     		  		      	              ) 
     		  		      	            )
     		  		      	           in
     		  		      	             Abs
     		  		      	                (
     		  		      	                 name
     		  		      	                	subst_rec
     		  		      	                	(
     		  		      	                	    subst
     		  		      	                	    Subst.add
     		  		      	                	    (
     		  		      	                	        key
     		  		      	                	        s
     		  		      	                	        data
     		  		      	                	        Var
     		  		      	                	           name
     		  		      	                	        subst
     		  		      	                	    )
     		  		      	                	    t
     		  		      	                	)
     		  		      	                )
     		  		      	           )
     		  		      	          )
     		  		      	          else
     		  		      	          (
     		  		      	           map_lambda
     		  		      	           (
     		  		      	               map_rec
     		  		      	               subst_rec
     		  		      	               (
     		  		      	                   subst
     		  		      	                   Subst.remove
     		  		      	                   (
     		  		      	                       s
     		  		      	                       subst
     		  		      	                   )
     		  		      	               )
     		  		      	               l
     		  		      	           )
     		  		      	          ) 
     		  		      	         )
     		  		      	       )
     		  		      	     )
     		  		      	    )
     		  		      	    case
     		  		      	    (
     		  		      	     alias l
     		  		      	     (
     		  		      	       App
     		  		      	       _
     		  		      	     )
     		  		      	     map_lambda
     		  		      	     (
     		  		      	         map_rec
     		  		      	         subst_rec
     		  		      	         (
     		  		      	             subst
     		  		      	             	subst
     		  		      	         )
     		  		      	         l
     		  		      	     )
     		  		      	    )
     		  		      	 )
     		  		         :
     		  				 arrow
     		  				  lambda
     		  				  (
     		  				  )
     		  				)
     		  		     )
     		  		)
     		     )
     		)
        )
   )
  )
  let
  (
     eval_lambda
   (
    case
        (
     		  eval_rec
     		(
     		 case
     		     (
     		  		 subst
     		  		(
     		  		 case
     		  		     (
     		  		 	  l
     		  		      match
     		  		      map_lambda
     		  		      (
     		  		          map_rec
     		  		          eval_rec
     		  		          l
     		  		      )
     		  		      (
     		  		      case
     		  		      (
     		  		        App
     		  		        (
     		  		         Abs
     		  		         (
     		  		          s
     		  		         	t1
     		  		         )
     		  		        	t2
     		  		        )
     		  		        eval_rec
     		  		        (
     		  		            subst
     		  		            (
     		  		                subst
     		  		                Subst.add
     		  		                (
     		  		                    key
     		  		                    s
     		  		                    data
     		  		                    t2
     		  		                    Subst.empty
     		  		                )
     		  		                t1
     		  		            )
     		  		        )
     		  		      ) 
     		  		        case
     		  		        (
     		  		         t
     		  		         t
     		  		        )
     		  		      )
     		  		     )
     		  		)
     		     )
     		)
        )
   )
  )
  let
  (
    free1
   (
    case
        (
    	  x
         free_lambda
         (
             free_rec
             free1
             x
         )
        )
   )
  )
  let
  (
    subst1
   (
    case
        (
    	  subst
         subst_lambda
         (
             subst_rec
             subst1
             free
             free1
             subst
             	subst
         )
        )
   )
  )
  let
  (
    eval1
   (
    case
        (
    	  x
         eval_lambda
         (
             eval_rec
             eval1
             subst
             subst1
             x
         )
        )
   )
  )
  type
  (  						
     expr
       type
       params=
       (
       a
       )
       cstrs =
       (
       )
       kind =
       (
       	  Var
       	  (
       	  	string
       	  	(
       	  	)
       	  )
       	  Num
       	  (
       	  	int
       	  	(
       	  	)
       	  )
       	  Add
       	  (
       	  	tuple
       	  	(
       	  	 a
       	  	  a
       	  	)
       	  )
       	  Neg
       	  (
       	  	a
       	  )
       	  Mult
       	  (
       	  	tuple
       	  	(
       	  	 a
       	  	  a
       	  	)
       	  )
       )
  )
  let
  (
    free_expr
   (
    case
        (
    	  free_rec
   	    (
         	 (
         	  case
         	  (
         	    alias x
         	    (
         	      var
         	    )
         	    free_var
         	    (
         	        x
         	    )
         	  ) 
         	    case
         	    (
         	     Num
         	     _
         	     Names.empty
         	    )
         	    case
         	    (
         	     Add
         	     (
         	      x
         	     	y
         	     )
         	     Names.union
         	     (
         	         free_rec
         	         (
         	             x
         	         )
         	         free_rec
         	         (
         	             y
         	         )
         	     )
         	    )
         	    case
         	    (
         	     Neg
         	     x
         	     free_rec
         	     (
         	         x
         	     )
         	    )
         	    case
         	    (
         	     Mult
         	     (
         	      x
         	     	y
         	     )
         	     Names.union
         	     (
         	         free_rec
         	         (
         	             x
         	         )
         	         free_rec
         	         (
         	             y
         	         )
         	     )
         	    )
         	 )
            :
   		 arrow
   		  expr
   		  (
   		  )
   		)
        )
   )
  )
  let
  (
    map_expr
   (
    case
        (
    	  map_rec
   	    (
         	 (
         	  case
         	  (
         	    alias x
         	    (
         	      var
         	    )
         	    x
         	  ) 
         	    case
         	    (
         	     alias x
         	     (
         	       Num
         	       _
         	     )
         	     x
         	    )
         	    case
         	    (
         	     alias e
         	     (
         	       Add
         	       (
         	        x
         	       	y
         	       )
         	     )
         	     let
         	     (
         	      (
         	        x'
         	        map_rec
         	        (
         	            x
         	        ) 
         	        y'
         	        map_rec
         	        (
         	            y
         	        ) 
         	      )
         	     in
         	       ifthenelse
         	       (
         	        if
         	        (
         	         &&
         	         (
         	             ==
         	             (
         	                 x
         	                 x'
         	             )
         	             ==
         	             (
         	                 y
         	                 y'
         	             )
         	         )
         	        )
         	        then
         	        (
         	         e
         	        )
         	        else
         	        (
         	         Add
         	            (
         	             x'
         	            	y'
         	            )
         	        ) 
         	       )
         	     )
         	    )
         	    case
         	    (
         	     alias e
         	     (
         	       Neg
         	       x
         	     )
         	     let
         	     (
         	      (
         	        x'
         	        map_rec
         	        (
         	            x
         	        ) 
         	      )
         	     in
         	       ifthenelse
         	       (
         	        if
         	        (
         	         ==
         	         (
         	             x
         	             x'
         	         )
         	        )
         	        then
         	        (
         	         e
         	        )
         	        else
         	        (
         	         Neg
         	            x'
         	        ) 
         	       )
         	     )
         	    )
         	    case
         	    (
         	     alias e
         	     (
         	       Mult
         	       (
         	        x
         	       	y
         	       )
         	     )
         	     let
         	     (
         	      (
         	        x'
         	        map_rec
         	        (
         	            x
         	        ) 
         	        y'
         	        map_rec
         	        (
         	            y
         	        ) 
         	      )
         	     in
         	       ifthenelse
         	       (
         	        if
         	        (
         	         &&
         	         (
         	             ==
         	             (
         	                 x
         	                 x'
         	             )
         	             ==
         	             (
         	                 y
         	                 y'
         	             )
         	         )
         	        )
         	        then
         	        (
         	         e
         	        )
         	        else
         	        (
         	         Mult
         	            (
         	             x'
         	            	y'
         	            )
         	        ) 
         	       )
         	     )
         	    )
         	 )
            :
   		 arrow
   		  expr
   		  (
   		  )
   		)
        )
   )
  )
  let
  (
     subst_expr
   (
    case
        (
     		 subst_rec
     		(
     		 case
     		     (
     		 	  subst
     			    (
     		      	 (
     		      	  case
     		      	  (
     		      	    alias x
     		      	    (
     		      	      var
     		      	    )
     		      	    subst_var
     		      	    (
     		      	        subst
     		      	        	subst
     		      	        x
     		      	    )
     		      	  ) 
     		      	    case
     		      	    (
     		      	     alias e
     		      	     (
     		      	       expr
     		      	     )
     		      	     map_expr
     		      	     (
     		      	         map_rec
     		      	         subst_rec
     		      	         (
     		      	             subst
     		      	             	subst
     		      	         )
     		      	         e
     		      	     )
     		      	    )
     		      	 )
     		         :
     				 arrow
     				  expr
     				  (
     				  )
     				)
     		     )
     		)
        )
   )
  )
  let
  (
     eval_expr
   (
    case
        (
     		 eval_rec
     		(
     		 case
     		     (
     		 	  e
     		      match
     		      map_expr
     		      (
     		          map_rec
     		          eval_rec
     		          e
     		      )
     		      (
     		      case
     		      (
     		        Add
     		        (
     		         Num
     		         m
     		        	Num
     		        	n
     		        )
     		        Num
     		           +
     		           (
     		               m
     		               n
     		           )
     		      ) 
     		        case
     		        (
     		         Neg
     		         Num
     		         n
     		         Num
     		            ~-
     		            (
     		             n
     		            )
     		        )
     		        case
     		        (
     		         Mult
     		         (
     		          Num
     		          m
     		         	Num
     		         	n
     		         )
     		         Num
     		            *
     		            (
     		                m
     		                n
     		            )
     		        )
     		        case
     		        (
     		         alias e
     		         (
     		           expr
     		         )
     		         e
     		        )
     		      )
     		     )
     		)
        )
   )
  )
  let
  (
    free2
   (
    case
        (
    	  x
         free_expr
         (
             free_rec
             free2
             x
         )
        )
   )
  )
  let
  (
    subst2
   (
    case
        (
    	  subst
         subst_expr
         (
             subst_rec
             subst2
             subst
             	subst
         )
        )
   )
  )
  let
  (
    eval2
   (
    case
        (
    	  x
         eval_expr
         (
             eval_rec
             eval2
             x
         )
        )
   )
  )
  type
  (  						
     lexpr
       type
       params=
       (
       )
       cstrs =
       (
       )
       kind =
       (
       	  Var
       	  (
       	  	string
       	  	(
       	  	)
       	  )
       	  Abs
       	  (
       	  	tuple
       	  	(
       	  	 string
       	  	 (
       	  	 )
       	  	  lexpr
       	  	  (
       	  	  )
       	  	)
       	  )
       	  App
       	  (
       	  	tuple
       	  	(
       	  	 lexpr
       	  	 (
       	  	 )
       	  	  lexpr
       	  	  (
       	  	  )
       	  	)
       	  )
       	  Num
       	  (
       	  	int
       	  	(
       	  	)
       	  )
       	  Add
       	  (
       	  	tuple
       	  	(
       	  	 lexpr
       	  	 (
       	  	 )
       	  	  lexpr
       	  	  (
       	  	  )
       	  	)
       	  )
       	  Neg
       	  (
       	  	lexpr
       	  	(
       	  	)
       	  )
       	  Mult
       	  (
       	  	tuple
       	  	(
       	  	 lexpr
       	  	 (
       	  	 )
       	  	  lexpr
       	  	  (
       	  	  )
       	  	)
       	  )
       )
  )
  let
  (
    free
    (
     (
      case
      (
        alias x
        (
          lambda
        )
        free_lambda
        (
            free_rec
            free
            x
        )
      ) 
        case
        (
         alias x
         (
           expr
         )
         free_expr
         (
             free_rec
             free
             x
         )
        )
     )
     :
     arrow
     lexpr
     (
     )
    )
  )
  let
  (
    subst
   (
    case
        (
    	  s
   	    (
         	 (
         	  case
         	  (
         	    alias x
         	    (
         	      lambda
         	    )
         	    subst_lambda
         	    (
         	        subst_rec
         	        subst
         	        subst
         	        s
         	        free
         	        	free
         	        x
         	    )
         	  ) 
         	    case
         	    (
         	     alias x
         	     (
         	       expr
         	     )
         	     subst_expr
         	     (
         	         subst_rec
         	         subst
         	         subst
         	         s
         	         x
         	     )
         	    )
         	 )
            :
   		 arrow
   		 lexpr
   		 (
   		 )
   		)
        )
   )
  )
  let
  (
    eval
    (
     (
      case
      (
        alias x
        (
          lambda
        )
        eval_lambda
        (
            eval_rec
            eval
            subst
            	subst
            x
        )
      ) 
        case
        (
         alias x
         (
           expr
         )
         eval_expr
         (
             eval_rec
             eval
             x
         )
        )
     )
     :
     arrow
     lexpr
     (
     )
    )
  )
  let
  (
    print
    (
     case
     (
       Var
       id
       print_string
       (
           id
       )
     ) 
       case
       (
        Abs
        (
         id
        	l
        )
        sequence
        (
          print_string
          (
              ^
              (
                  "\ "
                  ^
                  (
                      id
                      " . "
                  )
              )
          )
        ;
          print
          (
              l
          )
        )
       )
       case
       (
        App
        (
         l1
        	l2
        )
        sequence
        (
          print
          (
              l1
          )
        ;
          sequence
          (
            print_string
            (
                " "
            )
          ;
            print
            (
                l2
            )
          )
        )
       )
       case
       (
        Num
        x
        print_int
        (
            x
        )
       )
       case
       (
        Add
        (
         e1
        	e2
        )
        sequence
        (
          print
          (
              e1
          )
        ;
          sequence
          (
            print_string
            (
                " + "
            )
          ;
            print
            (
                e2
            )
          )
        )
       )
       case
       (
        Neg
        e
        sequence
        (
          print_string
          (
              "-"
          )
        ;
          print
          (
              e
          )
        )
       )
       case
       (
        Mult
        (
         e1
        	e2
        )
        sequence
        (
          print
          (
              e1
          )
        ;
          sequence
          (
            print_string
            (
                " * "
            )
          ;
            print
            (
                e2
            )
          )
        )
       )
    )
  )
  let
  (
    ()
    let
    (
     (
       e1
       eval1
       (
           App
              (
               Abs
                  (
                   "x"
                  	Var
                  	   "x"
                  )
              	Var
              	   "y"
              )
       ) 
     )
    in
      let
      (
       (
         e2
         eval2
         (
             Add
                (
                 Mult
                    (
                     Num
                        3
                    	Neg
                    	   Num
                    	      2
                    )
                	Var
                	   "x"
                )
         ) 
       )
      in
        let
        (
         (
           e3
           eval
           (
               Add
                  (
                   App
                      (
                       Abs
                          (
                           "x"
                          	Mult
                          	   (
                          	    Var
                          	       "x"
                          	   	Var
                          	   	   "x"
                          	   )
                          )
                      	Num
                      	   2
                      )
                  	Num
                  	   5
                  )
           ) 
         )
        in
          sequence
          (
            print
            (
                e1
            )
          ;
            sequence
            (
              print_newline
              (
                  ()
              )
            ;
              sequence
              (
                print
                (
                    e2
                )
              ;
                sequence
                (
                  print_newline
                  (
                      ()
                  )
                ;
                  sequence
                  (
                    print
                    (
                        e3
                    )
                  ;
                    print_newline
                    (
                        ()
                    )
                  )
                )
              )
            )
          )
        )
      )
    )
  )
)
