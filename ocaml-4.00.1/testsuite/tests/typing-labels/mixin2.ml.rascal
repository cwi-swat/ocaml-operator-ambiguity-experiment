
(
    								 
  open StdLabels
                                     
  open MoreLabels
                                     
  module  Subst
   
       								  
    Map.Make
       							     
   (
   struct
   (
   							  
   type
   (  						
       							    	 
      t
      type
      params=
      (
      
      )
      cstrs =
      (
      )
      kind =
      
      string
      (
      )
      								  
      
      														  
      														 
     											   
   								        
   )
   							  
   let
   (
    
     compare
     compare 
    							    		    
   )
   							  
   )
   							  
   )
   								   
  										    
                                     
  module  Names
   
       								  
    Set.Make
       							     
   (
   struct
   (
   							  
   type
   (  						
       							    	 
      t
      type
      params=
      (
      
      )
      cstrs =
      (
      )
      kind =
      
      string
      (
      )
      								  
      
      														  
      														 
     											   
   								        
   )
   							  
   let
   (
    
     compare
     compare 
    							    		    
   )
   							  
   )
   							  
   )
   								   
  										    
                                     
  let
  (
   
    lazy_fix
   (
    case
        (
    	  make
         
         let
         (
          (
             									  
           
            obj
           (
            case
                (
            	  ()
                 make
                 (
                     
                     (
                     lazy 
                     (
                         obj
                         (
                             ()
                         )
                     )
                     :
                     
                      "extendedModulePath1"([],"Lazy")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()].t
                      (
                        <>
                      )
                      
                         									
                     )
                         								
                 )
                )
           )
               		   
             									  
          )
         in
           obj
           (
               ()
           )
         )
             									
        )
   )
       		    
  )
                                     
  let
  (
   
    !
    !
    Lazy.force 
   							    		    
  )
                                     
  classTypeDef 
  (
      classTypeDefinition 
      (
          classTypeDef 
          (
              
              <"a",["b"]>
              ops
              <[],[<[],[],"free","arrow1"("tagg"("b")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()],"typexprConstr2"("typeConstr"(["extendedModulePath1"([],"Names")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]],"t")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>,<[],[],"subst","arrow2"([],"sub","typexprConstr1"("tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"typeConstr"(["extendedModulePath1"([],"Subst")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]],"t")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"arrow1"("tagg"("b")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()],"tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>,<[],[],"eval","arrow1"("tagg"("b")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]>]>
          )
          
      )
  )
                                     
  type
  (  						
      							    	 
     var
     type
     params=
     (
     
     )
     cstrs =
     (
     )
     kind =
     <[],[<"Var",["typexprConstr2"("typeConstr"([],"string")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]]>]>
     
     														  
     														 
    											   
  								        
  )
                                     
  class
  (
      								   
    params = 
    (
        	
    )
    class name = var_ops
    class expr = 
                class_structure
                (
                    								
                   classConstraint 
                   (
                       a
                       
                       var
                       (
                       )
                       								  
                   )
                    								
                   method subst
                         
                         try
                         Subst.find
                         (
                             s
                             sub
                         )
                         (
                         
                         case
                         (
                           Not_found
                           
                           x
                         ) 
                         	        											 
                         	        											 
                         )
                             							   
                       												 
                    								
                   method free
                         Names.singleton
                         (
                             s
                         )
                       												 
                    								
                   method eval
                         v
                       												 
                    								
                )
                    								
        	
      								   
  )
      								   
                                     
  type
  (  						
      							    	 
     lambda
     type
     params=
     (
     
      
      a
     										 
     )
     cstrs =
     (
     )
     kind =
     <[],[<"Var",["typexprConstr2"("typeConstr"([],"string")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]]>,<"Abs",["star"("typexprConstr2"("typeConstr"([],"string")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()],["tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]]>,<"App",["star"("tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],["tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]]>]>
     
     														  
     														 
    											   
  								        
  )
                                     
  let
  (
   
    next_id
    
    let
    (
     (
        									  
      
       current
       ref
       (
           3
       ) 
      							    		   
        									  
     )
    in
      (
       
       case
       (
       ()
       
       
       sequence
       (
         incr
         (
             current
         )
       ;
         
          !
          (
          current
          )
             							 
       )
           							
       )
       													 
      )
         						  
    )
        									 
   							    		    
  )
                                     
  class
  (
      								   
    params = 
    (
        	
    
    ops
    
     "extendedModulePath1"([],"Lazy")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()].t
     (
       <["tagg"("a")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()],"tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],"classPath"([],"ops")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]>
     )
     
        									
        										   
        	
    )
    class name = lambda_ops
    class expr = 
                letClass 
                (
                    
                    
                     var
                     new var_ops 
                    							    		   
                    
                     free
                     lazy 
                     (
                         send free
                         (
                          
                           !!
                           (
                           ops
                           )
                              							 
                         )
                             						  
                     ) 
                    							    		   
                    
                     subst
                     lazy 
                     (
                         send subst
                         (
                          
                           !!
                           (
                           ops
                           )
                              							 
                         )
                             						  
                     ) 
                    							    		   
                    
                     eval
                     lazy 
                     (
                         send eval
                         (
                          
                           !!
                           (
                           ops
                           )
                              							 
                         )
                             						  
                     ) 
                    							    		   
                    class_structure
                    (
                        								
                       classConstraint 
                       (
                           a
                           
                            lambda
                            (
                              a
                            )
                            
                               									
                       )
                        								
                       method free
                             (
                              
                              case
                              (
                                patternAs 
                                (
                                    var
                                    x
                                )
                                
                                send free
                                (
                                 var
                                )
                                    						  
                                (
                                    x
                                )
                              ) 
                              	        											 
                                
                                case
                                (
                                 tagNamePattern 
                                 (
                                     Abs
                                     
                                     (
                                      s
                                          						 
                                     	t
                                     
                                     )
                                 )
                                 
                                 Names.remove
                                 (
                                     s
                                     
                                      !!
                                      (
                                      free
                                      )
                                         							 
                                     (
                                         t
                                     )
                                 )
                                )
                                													    
                              	        											 
                                
                                case
                                (
                                 tagNamePattern 
                                 (
                                     App
                                     
                                     (
                                      t1
                                          						 
                                     	t2
                                     
                                     )
                                 )
                                 
                                 Names.union
                                 (
                                     
                                      !!
                                      (
                                      free
                                      )
                                         							 
                                     (
                                         t1
                                     )
                                     
                                      !!
                                      (
                                      free
                                      )
                                         							 
                                     (
                                         t2
                                     )
                                 )
                                )
                                													    
                              	        											 
                              	        											 
                             )
                                							   
                           												 
                        								
                       method map
                             (
                              
                              case
                              (
                                patternAs 
                                (
                                    var
                                    x
                                )
                                
                                x
                              ) 
                              	        											 
                                
                                case
                                (
                                 patternAs 
                                 (
                                     tagNamePattern 
                                     (
                                         Abs
                                         
                                         (
                                          s
                                              						 
                                         	t
                                         
                                         )
                                     )
                                     l
                                 )
                                 
                                 
                                 let
                                 (
                                  (
                                     									  
                                   
                                    t'
                                    f
                                    (
                                        t
                                    ) 
                                   							    		   
                                     									  
                                  )
                                 in
                                   ifthenelse
                                   (
                                    if
                                    (
                                     ==
                                     (
                                         t
                                         t'
                                     )
                                    )
                                    then
                                    (
                                     l
                                    )
                                    else
                                    (
                                     Abs
                                     (
                                         
                                         (
                                             					 s
                                             					 
                                         	t'
                                             					 
                                         )
                                             					 
                                     )
                                    ) 
                                   )
                                   		    											 
                                 )
                                     									
                                )
                                													    
                              	        											 
                                
                                case
                                (
                                 patternAs 
                                 (
                                     tagNamePattern 
                                     (
                                         App
                                         
                                         (
                                          t1
                                              						 
                                         	t2
                                         
                                         )
                                     )
                                     l
                                 )
                                 
                                 
                                 let
                                 (
                                  (
                                     									  
                                   
                                    t'1
                                    f
                                    (
                                        t1
                                    ) 
                                   							    		   
                                     									  
                                   
                                    t'2
                                    f
                                    (
                                        t2
                                    ) 
                                   							    		   
                                     									  
                                  )
                                 in
                                   ifthenelse
                                   (
                                    if
                                    (
                                     &&
                                     (
                                         ==
                                         (
                                             t'1
                                             t1
                                         )
                                         ==
                                         (
                                             t'2
                                             t2
                                         )
                                     )
                                    )
                                    then
                                    (
                                     l
                                    )
                                    else
                                    (
                                     App
                                     (
                                         
                                         (
                                             					 t'1
                                             					 
                                         	t'2
                                             					 
                                         )
                                             					 
                                     )
                                    ) 
                                   )
                                   		    											 
                                 )
                                     									
                                )
                                													    
                              	        											 
                              	        											 
                             )
                                							   
                           												 
                        								
                       method subst
                             (
                              
                              case
                              (
                                patternAs 
                                (
                                    var
                                    x
                                )
                                
                                send subst
                                (
                                 var
                                )
                                    						  
                                (
                                    sub
                                    x
                                )
                              ) 
                              	        											 
                                
                                case
                                (
                                 patternAs 
                                 (
                                     tagNamePattern 
                                     (
                                         Abs
                                         
                                         (
                                          s
                                              						 
                                         	t
                                         
                                         )
                                     )
                                     l
                                 )
                                 
                                 
                                 let
                                 (
                                  (
                                     									  
                                   
                                    used
                                    
                                     !!
                                     (
                                     free
                                     )
                                        							 
                                    (
                                        t
                                    ) 
                                   							    		   
                                     									  
                                  )
                                 in
                                   
                                   let
                                   (
                                    (
                                       									  
                                     
                                      used_expr
                                      Subst.fold
                                      (
                                          sub
                                          <"~init:","constant"("emptyBrackets"()[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]>
                                          <"~f:","brackets"("fun"("multipleMatching"(["key","data","patternValueName"("acc")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],[],"ifThenElse"("functionApplication"("valuePath"("valuePath"(["modulePath"([],"Names")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]],"mem")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()],["valuePath"("valuePath"([],"s")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()],"valuePath"("valuePath"([],"used")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()],"coloncolon"("valuePath"("valuePath"([],"data")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"valuePath"("valuePath"([],"acc")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()],"valuePath"("valuePath"([],"acc")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
                                      ) 
                                     							    		   
                                       									  
                                    )
                                   in
                                     ifthenelse
                                     (
                                      if
                                      (
                                       List.exists
                                       (
                                           used_expr
                                           <"~f:","brackets"("fun"("multipleMatching"(["patternValueName"("t")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]],[],"functionApplication"("valuePath"("valuePath"(["modulePath"([],"Names")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]],"mem")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],["valuePath"("valuePath"([],"s")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()],"brackets"("functionApplication"("prefix"("!!","valuePath"("valuePath"([],"free")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()],["valuePath"("valuePath"([],"t")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
                                       )
                                      )
                                      then
                                      (
                                       
                                       let
                                       (
                                        (
                                           									  
                                         
                                          name
                                          ^
                                          (
                                              s
                                              string_of_int
                                              (
                                                  next_id
                                                  (
                                                      ()
                                                  )
                                              )
                                          ) 
                                         							    		   
                                           									  
                                        )
                                       in
                                         Abs
                                         (
                                             
                                             (
                                                 					 name
                                                 					 
                                             	
                                             	 !!
                                             	 (
                                             	 subst
                                             	 )
                                             	    							 
                                             	(
                                             	    <"~sub:","brackets"("functionApplication"("valuePath"("valuePath"(["modulePath"([],"Subst")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],"add")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],[<"~key:","valuePath"("valuePath"([],"s")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]>,<"~data:","brackets"("functionApplication"("constant"("Var")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],["valuePath"("valuePath"([],"name")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>,"valuePath"("valuePath"([],"sub")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
                                             	    t
                                             	)
                                                 					 
                                             )
                                                 					 
                                         )
                                       )
                                           									
                                      )
                                      else
                                      (
                                       send map
                                       (
                                        self
                                       )
                                           						  
                                       (
                                           <"~f:","brackets"("functionApplication"("prefix"("!!","valuePath"("valuePath"([],"subst")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],[<"~sub:","brackets"("functionApplication"("valuePath"("valuePath"(["modulePath"([],"Subst")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],"remove")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()],["valuePath"("valuePath"([],"s")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"valuePath"("valuePath"([],"sub")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
                                           l
                                       )
                                      ) 
                                     )
                                     		    											 
                                   )
                                       									
                                 )
                                     									
                                )
                                													    
                              	        											 
                                
                                case
                                (
                                 patternAs 
                                 (
                                     tagNamePattern 
                                     (
                                         App
                                         _
                                     )
                                     l
                                 )
                                 
                                 send map
                                 (
                                  self
                                 )
                                     						  
                                 (
                                     <"~f:","brackets"("functionApplication"("prefix"("!!","valuePath"("valuePath"([],"subst")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],["sub"])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
                                     l
                                 )
                                )
                                													    
                              	        											 
                              	        											 
                             )
                                							   
                           												 
                        								
                       method eval
                             match
                             send map
                             (
                              self
                             )
                                 						  
                             (
                                 <"~f:","prefix"("!!","valuePath"("valuePath"([],"eval")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
                                 l
                             )
                             (
                             
                             case
                             (
                               tagNamePattern 
                               (
                                   App
                                   
                                   (
                                    tagNamePattern 
                                    (
                                        Abs
                                        
                                        (
                                         s
                                             						 
                                        	t1
                                        
                                        )
                                    )
                                        						 
                                   	t2
                                   
                                   )
                               )
                               
                               
                                !!
                                (
                                eval
                                )
                                   							 
                               (
                                   
                                    !!
                                    (
                                    subst
                                    )
                                       							 
                                   (
                                       <"~sub:","brackets"("functionApplication"("valuePath"("valuePath"(["modulePath"([],"Subst")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],"add")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()],[<"~key:","valuePath"("valuePath"([],"s")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>,<"~data:","valuePath"("valuePath"([],"t2")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]>,"valuePath"("valuePath"(["modulePath"([],"Subst")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],"empty")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]>
                                       t1
                                   )
                               )
                             ) 
                             	        											 
                               
                               case
                               (
                                t
                                
                                t
                               )
                               													    
                             	        											 
                             	        											 
                             )
                             			   
                           												 
                        								
                    )
                        								
                )
        	
      								   
  )
      								   
                                     
  let
  (
   
    lambda
    lazy_fix
    (
        new lambda_ops
    ) 
   							    		    
  )
                                     
  type
  (  						
      							    	 
     expr
     type
     params=
     (
     
      
      a
     										 
     )
     cstrs =
     (
     )
     kind =
     <[],[<"Var",["typexprConstr2"("typeConstr"([],"string")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>,<"Num",["typexprConstr2"("typeConstr"([],"int")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]]>,<"Add",["star"("tagg"("a")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()],["tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]]>,<"Neg",["tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>,<"Mult",["star"("tagg"("a")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()],["tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]]>]>
     
     														  
     														 
    											   
  								        
  )
                                     
  class
  (
      								   
    params = 
    (
        	
    
    ops
    
     "extendedModulePath1"([],"Lazy")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()].t
     (
       <["tagg"("a")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()],"tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],"classPath"([],"ops")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]>
     )
     
        									
        										   
        	
    )
    class name = expr_ops
    class expr = 
                letClass 
                (
                    
                    
                     var
                     new var_ops 
                    							    		   
                    
                     free
                     lazy 
                     (
                         send free
                         (
                          
                           !!
                           (
                           ops
                           )
                              							 
                         )
                             						  
                     ) 
                    							    		   
                    
                     subst
                     lazy 
                     (
                         send subst
                         (
                          
                           !!
                           (
                           ops
                           )
                              							 
                         )
                             						  
                     ) 
                    							    		   
                    
                     eval
                     lazy 
                     (
                         send eval
                         (
                          
                           !!
                           (
                           ops
                           )
                              							 
                         )
                             						  
                     ) 
                    							    		   
                    class_structure
                    (
                        								
                       classConstraint 
                       (
                           a
                           
                            expr
                            (
                              a
                            )
                            
                               									
                       )
                        								
                       method free
                             (
                              
                              case
                              (
                                patternAs 
                                (
                                    var
                                    x
                                )
                                
                                send free
                                (
                                 var
                                )
                                    						  
                                (
                                    x
                                )
                              ) 
                              	        											 
                                
                                case
                                (
                                 tagNamePattern 
                                 (
                                     Num
                                     _
                                 )
                                 
                                 Names.empty
                                )
                                													    
                              	        											 
                                
                                case
                                (
                                 tagNamePattern 
                                 (
                                     Add
                                     
                                     (
                                      x
                                          						 
                                     	y
                                     
                                     )
                                 )
                                 
                                 Names.union
                                 (
                                     
                                      !!
                                      (
                                      free
                                      )
                                         							 
                                     (
                                         x
                                     )
                                     
                                      !!
                                      (
                                      free
                                      )
                                         							 
                                     (
                                         y
                                     )
                                 )
                                )
                                													    
                              	        											 
                                
                                case
                                (
                                 tagNamePattern 
                                 (
                                     Neg
                                     x
                                 )
                                 
                                 
                                  !!
                                  (
                                  free
                                  )
                                     							 
                                 (
                                     x
                                 )
                                )
                                													    
                              	        											 
                                
                                case
                                (
                                 tagNamePattern 
                                 (
                                     Mult
                                     
                                     (
                                      x
                                          						 
                                     	y
                                     
                                     )
                                 )
                                 
                                 Names.union
                                 (
                                     
                                      !!
                                      (
                                      free
                                      )
                                         							 
                                     (
                                         x
                                     )
                                     
                                      !!
                                      (
                                      free
                                      )
                                         							 
                                     (
                                         y
                                     )
                                 )
                                )
                                													    
                              	        											 
                              	        											 
                             )
                                							   
                           												 
                        								
                       method map
                             (
                              
                              case
                              (
                                patternAs 
                                (
                                    var
                                    x
                                )
                                
                                x
                              ) 
                              	        											 
                                
                                case
                                (
                                 patternAs 
                                 (
                                     tagNamePattern 
                                     (
                                         Num
                                         _
                                     )
                                     x
                                 )
                                 
                                 x
                                )
                                													    
                              	        											 
                                
                                case
                                (
                                 patternAs 
                                 (
                                     tagNamePattern 
                                     (
                                         Add
                                         
                                         (
                                          x
                                              						 
                                         	y
                                         
                                         )
                                     )
                                     e
                                 )
                                 
                                 
                                 let
                                 (
                                  (
                                     									  
                                   
                                    x'
                                    f
                                    (
                                        x
                                    ) 
                                   							    		   
                                     									  
                                   
                                    y'
                                    f
                                    (
                                        y
                                    ) 
                                   							    		   
                                     									  
                                  )
                                 in
                                   ifthenelse
                                   (
                                    if
                                    (
                                     &&
                                     (
                                         ==
                                         (
                                             x
                                             x'
                                         )
                                         ==
                                         (
                                             y
                                             y'
                                         )
                                     )
                                    )
                                    then
                                    (
                                     e
                                    )
                                    else
                                    (
                                     Add
                                     (
                                         
                                         (
                                             					 x'
                                             					 
                                         	y'
                                             					 
                                         )
                                             					 
                                     )
                                    ) 
                                   )
                                   		    											 
                                 )
                                     									
                                )
                                													    
                              	        											 
                                
                                case
                                (
                                 patternAs 
                                 (
                                     tagNamePattern 
                                     (
                                         Neg
                                         x
                                     )
                                     e
                                 )
                                 
                                 
                                 let
                                 (
                                  (
                                     									  
                                   
                                    x'
                                    f
                                    (
                                        x
                                    ) 
                                   							    		   
                                     									  
                                  )
                                 in
                                   ifthenelse
                                   (
                                    if
                                    (
                                     ==
                                     (
                                         x
                                         x'
                                     )
                                    )
                                    then
                                    (
                                     e
                                    )
                                    else
                                    (
                                     Neg
                                     (
                                         x'
                                     )
                                    ) 
                                   )
                                   		    											 
                                 )
                                     									
                                )
                                													    
                              	        											 
                                
                                case
                                (
                                 patternAs 
                                 (
                                     tagNamePattern 
                                     (
                                         Mult
                                         
                                         (
                                          x
                                              						 
                                         	y
                                         
                                         )
                                     )
                                     e
                                 )
                                 
                                 
                                 let
                                 (
                                  (
                                     									  
                                   
                                    x'
                                    f
                                    (
                                        x
                                    ) 
                                   							    		   
                                     									  
                                   
                                    y'
                                    f
                                    (
                                        y
                                    ) 
                                   							    		   
                                     									  
                                  )
                                 in
                                   ifthenelse
                                   (
                                    if
                                    (
                                     &&
                                     (
                                         ==
                                         (
                                             x
                                             x'
                                         )
                                         ==
                                         (
                                             y
                                             y'
                                         )
                                     )
                                    )
                                    then
                                    (
                                     e
                                    )
                                    else
                                    (
                                     Mult
                                     (
                                         
                                         (
                                             					 x'
                                             					 
                                         	y'
                                             					 
                                         )
                                             					 
                                     )
                                    ) 
                                   )
                                   		    											 
                                 )
                                     									
                                )
                                													    
                              	        											 
                              	        											 
                             )
                                							   
                           												 
                        								
                       method subst
                             (
                              
                              case
                              (
                                patternAs 
                                (
                                    var
                                    x
                                )
                                
                                send subst
                                (
                                 var
                                )
                                    						  
                                (
                                    sub
                                    x
                                )
                              ) 
                              	        											 
                                
                                case
                                (
                                 patternAs 
                                 (
                                     expr
                                     e
                                 )
                                 
                                 send map
                                 (
                                  self
                                 )
                                     						  
                                 (
                                     <"~f:","brackets"("functionApplication"("prefix"("!!","valuePath"("valuePath"([],"subst")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],["sub"])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()]>
                                     e
                                 )
                                )
                                													    
                              	        											 
                              	        											 
                             )
                                							   
                           												 
                        								
                       method eval
                             match
                             send map
                             (
                              self
                             )
                                 						  
                             (
                                 <"~f:","prefix"("!!","valuePath"("valuePath"([],"eval")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
                                 e
                             )
                             (
                             
                             case
                             (
                               tagNamePattern 
                               (
                                   Add
                                   
                                   (
                                    tagNamePattern 
                                    (
                                        Num
                                        m
                                    )
                                        						 
                                   	tagNamePattern 
                                   	(
                                   	    Num
                                   	    n
                                   	)
                                   
                                   )
                               )
                               
                               Num
                               (
                                   +
                                   (
                                       m
                                       n
                                   )
                               )
                             ) 
                             	        											 
                               
                               case
                               (
                                tagNamePattern 
                                (
                                    Neg
                                    tagNamePattern 
                                    (
                                        Num
                                        n
                                    )
                                )
                                
                                Num
                                (
                                    -n
                                )
                               )
                               													    
                             	        											 
                               
                               case
                               (
                                tagNamePattern 
                                (
                                    Mult
                                    
                                    (
                                     tagNamePattern 
                                     (
                                         Num
                                         m
                                     )
                                         						 
                                    	tagNamePattern 
                                    	(
                                    	    Num
                                    	    n
                                    	)
                                    
                                    )
                                )
                                
                                Num
                                (
                                    *
                                    (
                                        m
                                        n
                                    )
                                )
                               )
                               													    
                             	        											 
                               
                               case
                               (
                                e
                                
                                e
                               )
                               													    
                             	        											 
                             	        											 
                             )
                             			   
                           												 
                        								
                    )
                        								
                )
        	
      								   
  )
      								   
                                     
  let
  (
   
    expr
    lazy_fix
    (
        new expr_ops
    ) 
   							    		    
  )
                                     
  type
  (  						
      							    	 
     lexpr
     type
     params=
     (
     
      
      a
     										 
     )
     cstrs =
     (
     )
     kind =
     <[],["typexprConstr1"("tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"typeConstr"([],"lambda")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"typexprConstr1"("tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"typeConstr"([],"expr")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)])[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]]>
     
     														  
     														 
    											   
  								        
  )
                                     
  class
  (
      								   
    params = 
    (
        	
    
    ops
    
     "extendedModulePath1"([],"Lazy")[@location=|dunno:///|(0,1,<1,1>,<1,1>),@comments=()].t
     (
       <["tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)],"tagg"("a")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]],"classPath"([],"ops")[@comments=(),@location=|dunno:///|(0,1,<1,1>,<1,1>)]>
     )
     
        									
        										   
        	
    )
    class name = lexpr_ops
    class expr = 
                letClass 
                (
                    
                    
                     lambda
                     new lambda_ops
                     (
                         ops
                     ) 
                    							    		   
                    
                    letClass 
                    (
                        
                        
                         expr
                         new expr_ops
                         (
                             ops
                         ) 
                        							    		   
                        
                        class_structure
                        (
                            								
                           classConstraint 
                           (
                               a
                               
                                lexpr
                                (
                                  a
                                )
                                
                                   									
                           )
                            								
                           method free
                                 (
                                  
                                  case
                                  (
                                    patternAs 
                                    (
                                        lambda
                                        x
                                    )
                                    
                                    send free
                                    (
                                     lambda
                                    )
                                        						  
                                    (
                                        x
                                    )
                                  ) 
                                  	        											 
                                    
                                    case
                                    (
                                     patternAs 
                                     (
                                         expr
                                         x
                                     )
                                     
                                     send free
                                     (
                                      expr
                                     )
                                         						  
                                     (
                                         x
                                     )
                                    )
                                    													    
                                  	        											 
                                  	        											 
                                 )
                                    							   
                               												 
                            								
                           method subst
                                 (
                                  
                                  case
                                  (
                                    patternAs 
                                    (
                                        lambda
                                        x
                                    )
                                    
                                    send subst
                                    (
                                     lambda
                                    )
                                        						  
                                    (
                                        sub
                                        x
                                    )
                                  ) 
                                  	        											 
                                    
                                    case
                                    (
                                     patternAs 
                                     (
                                         expr
                                         x
                                     )
                                     
                                     send subst
                                     (
                                      expr
                                     )
                                         						  
                                     (
                                         sub
                                         x
                                     )
                                    )
                                    													    
                                  	        											 
                                  	        											 
                                 )
                                    							   
                               												 
                            								
                           method eval
                                 (
                                  
                                  case
                                  (
                                    patternAs 
                                    (
                                        lambda
                                        x
                                    )
                                    
                                    send eval
                                    (
                                     lambda
                                    )
                                        						  
                                    (
                                        x
                                    )
                                  ) 
                                  	        											 
                                    
                                    case
                                    (
                                     patternAs 
                                     (
                                         expr
                                         x
                                     )
                                     
                                     send eval
                                     (
                                      expr
                                     )
                                         						  
                                     (
                                         x
                                     )
                                    )
                                    													    
                                  	        											 
                                  	        											 
                                 )
                                    							   
                               												 
                            								
                        )
                            								
                    )
                )
        	
      								   
  )
      								   
                                     
  let
  (
   
    lexpr
    lazy_fix
    (
        new lexpr_ops
    ) 
   							    		    
  )
                                     
  let
  (
   
    print
    (
     
     case
     (
       tagNamePattern 
       (
           Var
           id
       )
       
       print_string
       (
           id
       )
     ) 
     	        											 
       
       case
       (
        tagNamePattern 
        (
            Abs
            
            (
             id
                 						 
            	l
            
            )
        )
        
        
        sequence
        (
          print_string
          (
              ^
              (
                  "\ "
                  ^
                  (
                      id
                      " . "
                  )
              )
          )
        ;
          print
          (
              l
          )
        )
            							
       )
       													    
     	        											 
       
       case
       (
        tagNamePattern 
        (
            App
            
            (
             l1
                 						 
            	l2
            
            )
        )
        
        
        sequence
        (
          print
          (
              l1
          )
        ;
          
          sequence
          (
            print_string
            (
                " "
            )
          ;
            print
            (
                l2
            )
          )
              							
        )
            							
       )
       													    
     	        											 
       
       case
       (
        tagNamePattern 
        (
            Num
            x
        )
        
        print_int
        (
            x
        )
       )
       													    
     	        											 
       
       case
       (
        tagNamePattern 
        (
            Add
            
            (
             e1
                 						 
            	e2
            
            )
        )
        
        
        sequence
        (
          print
          (
              e1
          )
        ;
          
          sequence
          (
            print_string
            (
                " + "
            )
          ;
            print
            (
                e2
            )
          )
              							
        )
            							
       )
       													    
     	        											 
       
       case
       (
        tagNamePattern 
        (
            Neg
            e
        )
        
        
        sequence
        (
          print_string
          (
              "-"
          )
        ;
          print
          (
              e
          )
        )
            							
       )
       													    
     	        											 
       
       case
       (
        tagNamePattern 
        (
            Mult
            
            (
             e1
                 						 
            	e2
            
            )
        )
        
        
        sequence
        (
          print
          (
              e1
          )
        ;
          
          sequence
          (
            print_string
            (
                " * "
            )
          ;
            print
            (
                e2
            )
          )
              							
        )
            							
       )
       													    
     	        											 
     	        											 
    )
       							    
   							    		    
  )
                                     
  let
  (
   
    ()
    
    let
    (
     (
        									  
      
       e1
       send eval
       (
        lambda
       )
           						  
       (
           App
           (
               
               (
                   					 Abs
                     					 (
                     					     
                     					     (
                     					         					 "x"
                     					         					 
                     					     	Var
                     					     	(
                     					     	    "x"
                     					     	)
                     					         					 
                     					     )
                     					         					 
                     					 )
                   					 
               	Var
               	(
               	    "y"
               	)
                   					 
               )
                   					 
           )
       ) 
      							    		   
        									  
     )
    in
      
      let
      (
       (
          									  
        
         e2
         send eval
         (
          expr
         )
             						  
         (
             Add
             (
                 
                 (
                     					 Mult
                       					 (
                       					     
                       					     (
                       					         					 Num
                       					           					 (
                       					           					     3
                       					           					 )
                       					         					 
                       					     	Neg
                       					     	(
                       					     	    Num
                       					     	    (
                       					     	        2
                       					     	    )
                       					     	)
                       					         					 
                       					     )
                       					         					 
                       					 )
                     					 
                 	Var
                 	(
                 	    "x"
                 	)
                     					 
                 )
                     					 
             )
         ) 
        							    		   
          									  
       )
      in
        
        let
        (
         (
            									  
          
           e3
           send eval
           (
            lexpr
           )
               						  
           (
               Add
               (
                   
                   (
                       					 App
                         					 (
                         					     
                         					     (
                         					         					 Abs
                         					           					 (
                         					           					     
                         					           					     (
                         					           					         					 "x"
                         					           					         					 
                         					           					     	Mult
                         					           					     	(
                         					           					     	    
                         					           					     	    (
                         					           					     	        					 Var
                         					           					     	          					 (
                         					           					     	          					     "x"
                         					           					     	          					 )
                         					           					     	        					 
                         					           					     	    	Var
                         					           					     	    	(
                         					           					     	    	    "x"
                         					           					     	    	)
                         					           					     	        					 
                         					           					     	    )
                         					           					     	        					 
                         					           					     	)
                         					           					         					 
                         					           					     )
                         					           					         					 
                         					           					 )
                         					         					 
                         					     	Num
                         					     	(
                         					     	    2
                         					     	)
                         					         					 
                         					     )
                         					         					 
                         					 )
                       					 
                   	Num
                   	(
                   	    5
                   	)
                       					 
                   )
                       					 
               )
           ) 
          							    		   
            									  
         )
        in
          
          sequence
          (
            print
            (
                e1
            )
          ;
            
            sequence
            (
              print_newline
              (
                  ()
              )
            ;
              
              sequence
              (
                print
                (
                    e2
                )
              ;
                
                sequence
                (
                  print_newline
                  (
                      ()
                  )
                ;
                  
                  sequence
                  (
                    print
                    (
                        e3
                    )
                  ;
                    print_newline
                    (
                        ()
                    )
                  )
                      							
                )
                    							
              )
                  							
            )
                							
          )
              							
        )
            									
      )
          									
    )
        									 
   							    		    
  )
                                     
)