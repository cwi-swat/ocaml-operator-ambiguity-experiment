(
  open Syntax
  type
  (
    regexp
      type
        params =
          (
          )
        cstrs =
          (
          )
        kind =
            (
              Empty
                (
                )
                              Chars
                (
                     int
                    (
                    )
                )
                              Action
                (
                     int
                    (
                    )
                )
                              Seq
                (
                     regexp
                    (
                    )
                     regexp
                    (
                    )
                )
                              Alt
                (
                     regexp
                    (
                    )
                     regexp
                    (
                    )
                )
                              Star
                (
                     regexp
                    (
                    )
                )
                            )
            )
  let
  (
    chars
      ref
      (
          (
          []
                    :
               list
              (
                   list
                  (
                       char
                      (
                      )
                  )
              )
                    )
      )
  )
  let
  (
    chars_count
      ref
      (
          0
      )
  )
  let
  (
    actions
      ref
      (
          (
          []
                    :
               list
              (
                  tuple
                  (
                       int
                      (
                      )
                       location
                      (
                      )
                  )
              )
                    )
      )
  )
  let
  (
    actions_count
      ref
      (
          0
      )
  )
  let
  (
    encode_regexp
      (
        case
        (
          Epsilon
                    Empty
                  )
        case
        (
          Characters
            cl
          let
          (
            (
              n
                !
                (
                    chars_count
                )
            )
          in
            sequence
            (
              :=
              (
                  chars
                  ::
                    (
                      cl
                      !
                      (
                          chars
                      )
                    )
              )
            ;
              sequence
              (
                :=
                (
                    chars_count
                    +
                    (
                        !
                        (
                            chars_count
                        )
                        1
                    )
                )
              ;
                Chars
                  n
              )
            )
          )
        )
        case
        (
          Sequence
            (
              r1
              r2
            )
          Seq
            (
              encode_regexp
              (
                  r1
              )
              encode_regexp
              (
                  r2
              )
            )
        )
        case
        (
          Alternative
            (
              r1
              r2
            )
          Alt
            (
              encode_regexp
              (
                  r1
              )
              encode_regexp
              (
                  r2
              )
            )
        )
        case
        (
          Repetition
            r
          Star
            encode_regexp
            (
                r
            )
        )
      )
  )
  let
  (
    encode_casedef
      List.fold_left
      (
          (
            case
            (
              reg
              (
                case
                (
                  (
                    expr
                    act
                  )
                  let
                  (
                    (
                      act_num
                        !
                        (
                            actions_count
                        )
                    )
                  in
                    sequence
                    (
                      :=
                      (
                          actions_count
                          +
                          (
                              !
                              (
                                  actions_count
                              )
                              1
                          )
                      )
                    ;
                      sequence
                      (
                        :=
                        (
                            actions
                            ::
                              (
                                (
                                  act_num
                                  act
                                )
                                !
                                (
                                    actions
                                )
                              )
                        )
                      ;
                        Alt
                          (
                            reg
                            Seq
                              (
                                encode_regexp
                                (
                                    expr
                                )
                                Action
                                  act_num
                              )
                          )
                      )
                    )
                  )
                )
              )
            )
          )
          Empty
                )
  )
  let
  (
    encode_lexdef
      (
        case
        (
          Lexdef
            (
              _
              ld
            )
          sequence
          (
            :=
            (
                chars
                []
                            )
          ;
            sequence
            (
              :=
              (
                  chars_count
                  0
              )
            ;
              sequence
              (
                :=
                (
                    actions
                    []
                                    )
              ;
                sequence
                (
                  :=
                  (
                      actions_count
                      0
                  )
                ;
                  let
                  (
                    (
                      name_regexp_list
                        List.map
                        (
                            (
                              case
                              (
                                (
                                  name
                                  casedef
                                )
                                (
                                  name
                                  encode_casedef
                                  (
                                      casedef
                                  )
                                )
                              )
                            )
                            ld
                        )
                    )
                  in
                    let
                    (
                      (
                        chr
                          Array.of_list
                          (
                              List.rev
                              (
                                  !
                                  (
                                      chars
                                  )
                              )
                          )
                        act
                          !
                          (
                              actions
                          )
                      )
                    in
                      sequence
                      (
                        :=
                        (
                            chars
                            []
                                                    )
                      ;
                        sequence
                        (
                          :=
                          (
                              actions
                              []
                                                        )
                        ;
                          (
                            chr
                            name_regexp_list
                            act
                          )
                        )
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
  )
  type
  (
    transition
      type
        params =
          (
          )
        cstrs =
          (
          )
        kind =
            (
              OnChars
                (
                     int
                    (
                    )
                )
                              ToAction
                (
                     int
                    (
                    )
                )
                            )
            )
  let
  (
    merge_trans
      (
        case
        (
          l1
          (
            case
            (
              l2
              match
              (
                l1
                l2
              )
              (
                case
                (
                  (
                    []
                                        s2
                  )
                  s2
                )
                case
                (
                  (
                    s1
                    []
                                      )
                  s1
                )
                case
                (
                  (
                    alias s1
                    (
                      ::
                        (
                          alias t1
                          (
                            OnChars
                              n1
                          )
                          r1
                        )
                    )
                    alias s2
                    (
                      ::
                        (
                          alias t2
                          (
                            OnChars
                              n2
                          )
                          r2
                        )
                    )
                  )
                  ifthenelse
                  (
                    if
                    (
                      =
                      (
                          n1
                          n2
                      )
                    )
                    then
                    (
                      ::
                        (
                          t1
                          merge_trans
                          (
                              r1
                              r2
                          )
                        )
                    )
                    else
                    (
                        ifthenelse
                        (
                          if
                          (
                            <
                            (
                                n1
                                n2
                            )
                          )
                          then
                          (
                            ::
                              (
                                t1
                                merge_trans
                                (
                                    r1
                                    s2
                                )
                              )
                          )
                          else
                          (
                              ::
                                (
                                  t2
                                  merge_trans
                                  (
                                      s1
                                      r2
                                  )
                                )
                          )
                        )
                    )
                  )
                )
                case
                (
                  (
                    alias s1
                    (
                      ::
                        (
                          alias t1
                          (
                            ToAction
                              n1
                          )
                          r1
                        )
                    )
                    alias s2
                    (
                      ::
                        (
                          alias t2
                          (
                            ToAction
                              n2
                          )
                          r2
                        )
                    )
                  )
                  ifthenelse
                  (
                    if
                    (
                      =
                      (
                          n1
                          n2
                      )
                    )
                    then
                    (
                      ::
                        (
                          t1
                          merge_trans
                          (
                              r1
                              r2
                          )
                        )
                    )
                    else
                    (
                        ifthenelse
                        (
                          if
                          (
                            <
                            (
                                n1
                                n2
                            )
                          )
                          then
                          (
                            ::
                              (
                                t1
                                merge_trans
                                (
                                    r1
                                    s2
                                )
                              )
                          )
                          else
                          (
                              ::
                                (
                                  t2
                                  merge_trans
                                  (
                                      s1
                                      r2
                                  )
                                )
                          )
                        )
                    )
                  )
                )
                case
                (
                  (
                    ::
                      (
                        alias t1
                        (
                          OnChars
                            n1
                        )
                        r1
                      )
                    alias s2
                    (
                      ::
                        (
                          ToAction
                            n2
                          r2
                        )
                    )
                  )
                  ::
                    (
                      t1
                      merge_trans
                      (
                          r1
                          s2
                      )
                    )
                )
                case
                (
                  (
                    alias s1
                    (
                      ::
                        (
                          ToAction
                            n1
                          r1
                        )
                    )
                    ::
                      (
                        alias t2
                        (
                          OnChars
                            n2
                        )
                        r2
                      )
                  )
                  ::
                    (
                      t2
                      merge_trans
                      (
                          s1
                          r2
                      )
                    )
                )
              )
            )
          )
        )
      )
  )
  let
  (
    nullable
      (
        case
        (
          Empty
                    true
                  )
        case
        (
          Chars
            _
          false
                  )
        case
        (
          Action
            _
          false
                  )
        case
        (
          Seq
            (
              r1
              r2
            )
          &&
          (
              nullable
              (
                  r1
              )
              nullable
              (
                  r2
              )
          )
        )
        case
        (
          Alt
            (
              r1
              r2
            )
          ||
          (
              nullable
              (
                  r1
              )
              nullable
              (
                  r2
              )
          )
        )
        case
        (
          Star
            r
          true
                  )
      )
  )
  let
  (
    firstpos
      (
        case
        (
          Empty
                    []
                  )
        case
        (
          Chars
            pos
          ::
            (
              OnChars
                pos
              []
                          )
        )
        case
        (
          Action
            act
          ::
            (
              ToAction
                act
              []
                          )
        )
        case
        (
          Seq
            (
              r1
              r2
            )
          ifthenelse
          (
            if
            (
              nullable
              (
                  r1
              )
            )
            then
            (
              merge_trans
              (
                  firstpos
                  (
                      r1
                  )
                  firstpos
                  (
                      r2
                  )
              )
            )
            else
            (
                firstpos
                (
                    r1
                )
            )
          )
        )
        case
        (
          Alt
            (
              r1
              r2
            )
          merge_trans
          (
              firstpos
              (
                  r1
              )
              firstpos
              (
                  r2
              )
          )
        )
        case
        (
          Star
            r
          firstpos
          (
              r
          )
        )
      )
  )
  let
  (
    lastpos
      (
        case
        (
          Empty
                    []
                  )
        case
        (
          Chars
            pos
          ::
            (
              OnChars
                pos
              []
                          )
        )
        case
        (
          Action
            act
          ::
            (
              ToAction
                act
              []
                          )
        )
        case
        (
          Seq
            (
              r1
              r2
            )
          ifthenelse
          (
            if
            (
              nullable
              (
                  r2
              )
            )
            then
            (
              merge_trans
              (
                  lastpos
                  (
                      r1
                  )
                  lastpos
                  (
                      r2
                  )
              )
            )
            else
            (
                lastpos
                (
                    r2
                )
            )
          )
        )
        case
        (
          Alt
            (
              r1
              r2
            )
          merge_trans
          (
              lastpos
              (
                  r1
              )
              lastpos
              (
                  r2
              )
          )
        )
        case
        (
          Star
            r
          lastpos
          (
              r
          )
        )
      )
  )
  let
  (
    followpos
      (
        case
        (
          size
          (
            case
            (
              name_regexp_list
              let
              (
                (
                  v
                    Array.create
                    (
                        size
                        []
                                            )
                )
              in
                let
                (
                  (
                    fill_pos
                      (
                        case
                        (
                          first
                          (
                            case
                            (
                              OnChars
                                pos
                              sequence
                              (
                                Array.set
                                (
                                    v
                                    pos
                                    merge_trans
                                    (
                                        first
                                        Array.get
                                        (
                                            v
                                            pos
                                        )
                                    )
                                )
                              ;
                                ()
                                                              )
                            )
                            case
                            (
                              ToAction
                                _
                              ()
                                                          )
                          )
                        )
                      )
                  )
                in
                  let
                  (
                    (
                      fill
                        (
                          case
                          (
                            Seq
                              (
                                r1
                                r2
                              )
                            sequence
                            (
                              fill
                              (
                                  r1
                              )
                            ;
                              sequence
                              (
                                fill
                                (
                                    r2
                                )
                              ;
                                List.iter
                                (
                                    fill_pos
                                    (
                                        firstpos
                                        (
                                            r2
                                        )
                                    )
                                    lastpos
                                    (
                                        r1
                                    )
                                )
                              )
                            )
                          )
                          case
                          (
                            Alt
                              (
                                r1
                                r2
                              )
                            sequence
                            (
                              fill
                              (
                                  r1
                              )
                            ;
                              fill
                              (
                                  r2
                              )
                            )
                          )
                          case
                          (
                            Star
                              r
                            sequence
                            (
                              fill
                              (
                                  r
                              )
                            ;
                              List.iter
                              (
                                  fill_pos
                                  (
                                      firstpos
                                      (
                                          r
                                      )
                                  )
                                  lastpos
                                  (
                                      r
                                  )
                              )
                            )
                          )
                          case
                          (
                            _
                            ()
                                                      )
                        )
                    )
                  in
                    sequence
                    (
                      List.iter
                      (
                          (
                            case
                            (
                              (
                                name
                                regexp
                              )
                              fill
                              (
                                  regexp
                              )
                            )
                          )
                          name_regexp_list
                      )
                    ;
                      v
                    )
                  )
                )
              )
            )
          )
        )
      )
  )
  let
  (
    no_action
      1073741823
  )
  let
  (
    split_trans_set
      List.fold_left
      (
          (
            case
            (
              alias act_pos_set
              (
                (
                  act
                  pos_set
                )
              )
              (
                case
                (
                  trans
                  match
                  trans
                  (
                    case
                    (
                      OnChars
                        pos
                      (
                        act
                        ::
                          (
                            pos
                            pos_set
                          )
                      )
                    )
                    case
                    (
                      ToAction
                        act1
                      ifthenelse
                      (
                        if
                        (
                          <
                          (
                              act1
                              act
                          )
                        )
                        then
                        (
                          (
                            act1
                            pos_set
                          )
                        )
                        else
                        (
                            act_pos_set
                        )
                      )
                    )
                  )
                )
              )
            )
          )
          (
            no_action
            []
                      )
      )
  )
  let
  (
    memory
      (
      Hashtbl.create
      (
          131
      )
      :
           Hashtbl.t
          (
               list
              (
                   transition
                  (
                  )
              )
               int
              (
              )
          )
            )
  )
  let
  (
    todo
      ref
      (
          (
          []
                    :
               list
              (
                  tuple
                  (
                       list
                      (
                           transition
                          (
                          )
                      )
                       int
                      (
                      )
                  )
              )
                    )
      )
  )
  let
  (
    next
      ref
      (
          0
      )
  )
  let
  (
    get_state
      (
        case
        (
          st
          try
          Hashtbl.find
          (
              memory
              st
          )
          (
            case
            (
              Not_found
                            let
              (
                (
                  nbr
                    !
                    (
                        next
                    )
                )
              in
                sequence
                (
                  :=
                  (
                      next
                      +
                      (
                          !
                          (
                              next
                          )
                          1
                      )
                  )
                ;
                  sequence
                  (
                    Hashtbl.add
                    (
                        memory
                        st
                        nbr
                    )
                  ;
                    sequence
                    (
                      :=
                      (
                          todo
                          ::
                            (
                              (
                                st
                                nbr
                              )
                              !
                              (
                                  todo
                              )
                            )
                      )
                    ;
                      nbr
                    )
                  )
                )
              )
            )
          )
        )
      )
  )
  let
  (
    map_on_states
      (
        case
        (
          f
          match
          !
          (
              todo
          )
          (
            case
            (
              []
                            []
                          )
            case
            (
              ::
                (
                  (
                    st
                    i
                  )
                  r
                )
              sequence
              (
                :=
                (
                    todo
                    r
                )
              ;
                let
                (
                  (
                    res
                      f
                      (
                          st
                      )
                  )
                in
                  ::
                    (
                      (
                        res
                        i
                      )
                      map_on_states
                      (
                          f
                      )
                    )
                )
              )
            )
          )
        )
      )
  )
  let
  (
    number_of_states
      (
        case
        (
          ()
                    !
          (
              next
          )
        )
      )
  )
  let
  (
    goto_state
      (
        case
        (
          []
                    Backtrack
                  )
        case
        (
          ps
          Goto
            get_state
            (
                ps
            )
        )
      )
  )
  let
  (
    transition_from
      (
        case
        (
          chars
          (
            case
            (
              follow
              (
                case
                (
                  pos_set
                  let
                  (
                    (
                      tr
                        Array.create
                        (
                            256
                            []
                                                    )
                      shift
                        Array.create
                        (
                            256
                            Backtrack
                                                    )
                    )
                  in
                    sequence
                    (
                      List.iter
                      (
                          (
                            case
                            (
                              pos
                              List.iter
                              (
                                  (
                                    case
                                    (
                                      c
                                      Array.set
                                      (
                                          tr
                                          Char.code
                                          (
                                              c
                                          )
                                          merge_trans
                                          (
                                              Array.get
                                              (
                                                  tr
                                                  Char.code
                                                  (
                                                      c
                                                  )
                                              )
                                              Array.get
                                              (
                                                  follow
                                                  pos
                                              )
                                          )
                                      )
                                    )
                                  )
                                  Array.get
                                  (
                                      chars
                                      pos
                                  )
                              )
                            )
                          )
                          pos_set
                      )
                    ;
                      sequence
                      (
                        for i
                        0
                        255
                        Array.set
                        (
                            shift
                            i
                            goto_state
                            (
                                Array.get
                                (
                                    tr
                                    i
                                )
                            )
                        )
                      ;
                        shift
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
  )
  let
  (
    translate_state
      (
        case
        (
          chars
          (
            case
            (
              follow
              (
                case
                (
                  state
                  match
                  split_trans_set
                  (
                      state
                  )
                  (
                    case
                    (
                      (
                        n
                        []
                                              )
                      Perform
                        n
                    )
                    case
                    (
                      (
                        n
                        ps
                      )
                      Shift
                        (
                          ifthenelse
                          (
                            if
                            (
                              =
                              (
                                  n
                                  no_action
                              )
                            )
                            then
                            (
                              No_remember
                                                          )
                            else
                            (
                                Remember
                                  n
                            )
                          )
                          transition_from
                          (
                              chars
                              follow
                              ps
                          )
                        )
                    )
                  )
                )
              )
            )
          )
        )
      )
  )
  let
  (
    make_dfa
      (
        case
        (
          lexdef
          let
          (
            (
              (
                chars
                name_regexp_list
                actions
              )
                encode_lexdef
                (
                    lexdef
                )
            )
          in
            let
            (
              (
                follow
                  followpos
                  (
                      Array.length
                      (
                          chars
                      )
                      name_regexp_list
                  )
              )
            in
              let
              (
                (
                  initial_states
                    List.map
                    (
                        (
                          case
                          (
                            (
                              name
                              regexp
                            )
                            (
                              name
                              get_state
                              (
                                  firstpos
                                  (
                                      regexp
                                  )
                              )
                            )
                          )
                        )
                        name_regexp_list
                    )
                )
              in
                let
                (
                  (
                    states
                      map_on_states
                      (
                          translate_state
                          (
                              chars
                              follow
                          )
                      )
                  )
                in
                  let
                  (
                    (
                      v
                        Array.create
                        (
                            number_of_states
                            (
                                ()
                                                            )
                            Perform
                              0
                        )
                    )
                  in
                    sequence
                    (
                      List.iter
                      (
                          (
                            case
                            (
                              (
                                auto
                                i
                              )
                              Array.set
                              (
                                  v
                                  i
                                  auto
                              )
                            )
                          )
                          states
                      )
                    ;
                      (
                        initial_states
                        v
                        actions
                      )
                    )
                  )
                )
              )
            )
          )
        )
      )
  )
)

