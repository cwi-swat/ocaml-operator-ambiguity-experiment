(
  let
  (
    test
      (
        case
        (
          number
          (
            case
            (
              result
              (
                case
                (
                  expected
                  sequence
                  (
                    ifthenelse
                    (
                      if
                      (
                        =
                        (
                            result
                            expected
                        )
                      )
                      then
                      (
                        Printf.printf
                        (
                            "Test %d passed.\n"
                            number
                        )
                      )
                      else
                      (
                          Printf.printf
                          (
                              "Test %d FAILED.\n"
                              number
                          )
                      )
                    )
                  ;
                    flush
                    (
                        stdout
                    )
                  )
                )
              )
            )
          )
        )
      )
  )
  Pstr_recmodule
  (
    "A"
        signature
        (
            type
            (
              t
                type
                  params =
                    (
                    )
                  cstrs =
                    (
                    )
                  kind =
                      (
                        Leaf
                          (
                               int
                              (
                              )
                          )
                                                  Node
                          (
                               ASet.t
                              (
                              )
                          )
                                                )
                                )
            sig_value compare
            value_description
                arrow
                
                   t
                  (
                  )
                  arrow
                  
                     t
                    (
                    )
                     int
                    (
                    )
              (
              )
        )
        struct
        (
          type
          (
            t
              type
                params =
                  (
                  )
                cstrs =
                  (
                  )
                kind =
                    (
                      Leaf
                        (
                             int
                            (
                            )
                        )
                                              Node
                        (
                             ASet.t
                            (
                            )
                        )
                                            )
                            )
          let
          (
            compare
              (
                case
                (
                  x
                  (
                    case
                    (
                      y
                      match
                      (
                        x
                        y
                      )
                      (
                        case
                        (
                          (
                            Leaf
                              i
                            Leaf
                              j
                          )
                          Pervasives.compare
                          (
                              i
                              j
                          )
                        )
                        case
                        (
                          (
                            Leaf
                              i
                            Node
                              t
                          )
                          -1
                        )
                        case
                        (
                          (
                            Node
                              s
                            Leaf
                              j
                          )
                          1
                        )
                        case
                        (
                          (
                            Node
                              s
                            Node
                              t
                          )
                          ASet.compare
                          (
                              s
                              t
                          )
                        )
                      )
                    )
                  )
                )
              )
          )
        )
    "ASet"
        Pmty_with
          Set.S
        (
          elt
            Pwith_type
              type
                params =
                  (
                  )
                cstrs =
                  (
                  )
                kind =
                  
                       A.t
                      (
                      )
        )
          Set.Make
        (
          A
        )
  )
  let
  (
    (
      x
        A.Node
          ASet.add
          (
              A.Leaf
                3
              ASet.singleton
              (
                  A.Leaf
                    2
              )
          )
    )
  in
    let
    (
      (
        y
          A.Node
            ASet.add
            (
                A.Leaf
                  1
                ASet.singleton
                (
                    x
                )
            )
      )
    in
      sequence
      (
        test
        (
            10
            A.compare
            (
                x
                x
            )
            0
        )
      ;
        sequence
        (
          test
          (
              11
              A.compare
              (
                  x
                  A.Leaf
                    3
              )
              1
          )
        ;
          sequence
          (
            test
            (
                12
                A.compare
                (
                    A.Leaf
                      0
                    x
                )
                -1
            )
          ;
            sequence
            (
              test
              (
                  13
                  A.compare
                  (
                      y
                      y
                  )
                  0
              )
            ;
              test
              (
                  14
                  A.compare
                  (
                      x
                      y
                  )
                  1
              )
            )
          )
        )
      )
    )
  )
  Pstr_recmodule
  (
    "Fib"
        signature
        (
            sig_value f
            value_description
                arrow
                
                   int
                  (
                  )
                   int
                  (
                  )
              (
              )
        )
        struct
        (
          let
          (
            f
              (
                case
                (
                  x
                  ifthenelse
                  (
                    if
                    (
                      <
                      (
                          x
                          2
                      )
                    )
                    then
                    (
                      1
                    )
                    else
                    (
                        +
                        (
                            Fib.f
                            (
                                -
                                (
                                    x
                                    1
                                )
                            )
                            Fib.f
                            (
                                -
                                (
                                    x
                                    2
                                )
                            )
                        )
                    )
                  )
                )
              )
          )
        )
  )
  test
  (
      20
      Fib.f
      (
          10
      )
      89
  )
  Pstr_recmodule
  (
    "Fib2"
        signature
        (
            sig_value f
            value_description
                arrow
                
                   int
                  (
                  )
                   int
                  (
                  )
              (
              )
        )
        struct
        (
          let
          (
            g
              (
                case
                (
                  x
                  +
                  (
                      Fib2.f
                      (
                          -
                          (
                              x
                              1
                          )
                      )
                      Fib2.f
                      (
                          -
                          (
                              x
                              2
                          )
                      )
                  )
                )
              )
            f
              (
                case
                (
                  x
                  ifthenelse
                  (
                    if
                    (
                      <
                      (
                          x
                          2
                      )
                    )
                    then
                    (
                      1
                    )
                    else
                    (
                        g
                        (
                            x
                        )
                    )
                  )
                )
              )
          )
        )
  )
  test
  (
      21
      Fib2.f
      (
          10
      )
      89
  )
  let
  (
    (
      res
        try
        let module A
        (
          struct
          (
            Pstr_recmodule
            (
              "Bad"
                  signature
                  (
                      sig_value f
                      value_description
                          arrow
                          
                             int
                            (
                            )
                             int
                            (
                            )
                        (
                        )
                  )
                  struct
                  (
                    let
                    (
                      f
                        let
                        (
                          (
                            y
                              Bad.f
                              (
                                  5
                              )
                          )
                        in
                          (
                            case
                            (
                              x
                              +
                              (
                                  x
                                  y
                              )
                            )
                          )
                        )
                    )
                  )
            )
          )
        )
        in
        (
        false
                )
        (
          case
          (
            Undefined_recursive_module
              _
            true
                      )
        )
    )
  in
    test
    (
        30
        res
        true
            )
  )
  Pstr_recmodule
  (
    "After"
        signature
        (
            sig_value x
            value_description
                 int
                (
                )
              (
              )
        )
        struct
        (
          let
          (
            x
              +
              (
                  Before.x
                  1
              )
          )
        )
    "Before"
        signature
        (
            sig_value x
            value_description
                 int
                (
                )
              (
              )
        )
        struct
        (
          let
          (
            x
              3
          )
        )
  )
  test
  (
      40
      After.x
      4
  )
  Pstr_recmodule
  (
    "Strengthen"
        signature
        (
            type
            (
              t
                type
                  params =
                    (
                    )
                  cstrs =
                    (
                    )
                  kind =
                    
                                )
            sig_value f
            value_description
                arrow
                
                   t
                  (
                  )
                   t
                  (
                  )
              (
              )
        )
        struct
        (
          type
          (
            t
              type
                params =
                  (
                  )
                cstrs =
                  (
                  )
                kind =
                    (
                      A
                        (
                        )
                                              B
                        (
                        )
                                            )
                            )
          (
          A
                    :
               Strengthen.t
              (
              )
                    )
          let
          (
            f
              (
                case
                (
                  x
                  ifthenelse
                  (
                    if
                    (
                      true
                                          )
                    then
                    (
                      A
                                          )
                    else
                    (
                        Strengthen.f
                        (
                            B
                                                    )
                    )
                  )
                )
              )
          )
        )
  )
  Pstr_recmodule
  (
    "Strengthen2"
        signature
        (
            type
            (
              t
                type
                  params =
                    (
                    )
                  cstrs =
                    (
                    )
                  kind =
                    
                                )
            sig_value f
            value_description
                arrow
                
                   t
                  (
                  )
                   t
                  (
                  )
              (
              )
            module M
              signature
              (
                  type
                  (
                    u
                      type
                        params =
                          (
                          )
                        cstrs =
                          (
                          )
                        kind =
                          
                                            )
              )
            module R
              signature
              (
                  type
                  (
                    v
                      type
                        params =
                          (
                          )
                        cstrs =
                          (
                          )
                        kind =
                          
                                            )
              )
        )
        struct
        (
          type
          (
            t
              type
                params =
                  (
                  )
                cstrs =
                  (
                  )
                kind =
                    (
                      A
                        (
                        )
                                              B
                        (
                        )
                                            )
                            )
          (
          A
                    :
               Strengthen2.t
              (
              )
                    )
          let
          (
            f
              (
                case
                (
                  x
                  ifthenelse
                  (
                    if
                    (
                      true
                                          )
                    then
                    (
                      A
                                          )
                    else
                    (
                        Strengthen2.f
                        (
                            B
                                                    )
                    )
                  )
                )
              )
          )
          module M
            struct
            (
              type
              (
                u
                  type
                    params =
                      (
                      )
                    cstrs =
                      (
                      )
                    kind =
                        (
                          C
                            (
                            )
                                                    )
                                    )
              (
              C
                            :
                   Strengthen2.M.u
                  (
                  )
                            )
            )
          Pstr_recmodule
          (
            "R"
                signature
                (
                    type
                    (
                      v
                        type
                          params =
                            (
                            )
                          cstrs =
                            (
                            )
                          kind =
                            
                                 Strengthen2.R.v
                                (
                                )
                    )
                )
                struct
                (
                  type
                  (
                    v
                      type
                        params =
                          (
                          )
                        cstrs =
                          (
                          )
                        kind =
                            (
                              D
                                (
                                )
                                                            )
                                            )
                  (
                  D
                                    :
                       R.v
                      (
                      )
                                    )
                  (
                  D
                                    :
                       Strengthen2.R.v
                      (
                      )
                                    )
                )
          )
        )
  )
  Pstr_recmodule
  (
    "PolyRec"
        signature
        (
            type
            (
              t
                type
                  params =
                    (
                      a
                    )
                  cstrs =
                    (
                    )
                  kind =
                      (
                        Leaf
                          (
                              a
                          )
                                                  Node
                          (
                               t
                              (
                                   list
                                  (
                                      a
                                  )
                              )
                               t
                              (
                                   list
                                  (
                                      a
                                  )
                              )
                          )
                                                )
                                )
            sig_value depth
            value_description
                arrow
                
                   t
                  (
                      a
                  )
                   int
                  (
                  )
              (
              )
        )
        struct
        (
          type
          (
            t
              type
                params =
                  (
                    a
                  )
                cstrs =
                  (
                  )
                kind =
                    (
                      Leaf
                        (
                            a
                        )
                                              Node
                        (
                             t
                            (
                                 list
                                (
                                    a
                                )
                            )
                             t
                            (
                                 list
                                (
                                    a
                                )
                            )
                        )
                                            )
                            )
          let
          (
            x
              (
              PolyRec.Leaf
                1
              :
                   t
                  (
                       int
                      (
                      )
                  )
                            )
          )
          let
          (
            depth
              (
                case
                (
                  Leaf
                    x
                  0
                )
                case
                (
                  Node
                    (
                      l
                      r
                    )
                  +
                  (
                      1
                      max
                      (
                          PolyRec.depth
                          (
                              l
                          )
                          PolyRec.depth
                          (
                              r
                          )
                      )
                  )
                )
              )
          )
        )
  )
  module StringSet
      Set.Make
    (
      String
    )
  Pstr_recmodule
  (
    "Expr"
        signature
        (
            type
            (
              t
                type
                  params =
                    (
                    )
                  cstrs =
                    (
                    )
                  kind =
                      (
                        Var
                          (
                               string
                              (
                              )
                          )
                                                  Const
                          (
                               int
                              (
                              )
                          )
                                                  Add
                          (
                               t
                              (
                              )
                               t
                              (
                              )
                          )
                                                  Binding
                          (
                               Binding.t
                              (
                              )
                               t
                              (
                              )
                          )
                                                )
                                )
            sig_value make_let
            value_description
                arrow
                
                   string
                  (
                  )
                  arrow
                  
                     t
                    (
                    )
                    arrow
                    
                       t
                      (
                      )
                       t
                      (
                      )
              (
              )
            sig_value fv
            value_description
                arrow
                
                   t
                  (
                  )
                   StringSet.t
                  (
                  )
              (
              )
            sig_value simpl
            value_description
                arrow
                
                   t
                  (
                  )
                   t
                  (
                  )
              (
              )
        )
        struct
        (
          type
          (
            t
              type
                params =
                  (
                  )
                cstrs =
                  (
                  )
                kind =
                    (
                      Var
                        (
                             string
                            (
                            )
                        )
                                              Const
                        (
                             int
                            (
                            )
                        )
                                              Add
                        (
                             t
                            (
                            )
                             t
                            (
                            )
                        )
                                              Binding
                        (
                             Binding.t
                            (
                            )
                             t
                            (
                            )
                        )
                                            )
                            )
          let
          (
            make_let
              (
                case
                (
                  id
                  (
                    case
                    (
                      e1
                      (
                        case
                        (
                          e2
                          Binding
                            (
                              ::
                                (
                                  (
                                    id
                                    e1
                                  )
                                  []
                                                                  )
                              e2
                            )
                        )
                      )
                    )
                  )
                )
              )
          )
          let
          (
            fv
              (
                case
                (
                  Var
                    s
                  StringSet.singleton
                  (
                      s
                  )
                )
                case
                (
                  Const
                    n
                  StringSet.empty
                )
                case
                (
                  Add
                    (
                      t1
                      t2
                    )
                  StringSet.union
                  (
                      fv
                      (
                          t1
                      )
                      fv
                      (
                          t2
                      )
                  )
                )
                case
                (
                  Binding
                    (
                      b
                      t
                    )
                  StringSet.union
                  (
                      Binding.fv
                      (
                          b
                      )
                      StringSet.diff
                      (
                          fv
                          (
                              t
                          )
                          Binding.bv
                          (
                              b
                          )
                      )
                  )
                )
              )
          )
          let
          (
            simpl
              (
                case
                (
                  Var
                    s
                  Var
                    s
                )
                case
                (
                  Const
                    n
                  Const
                    n
                )
                case
                (
                  Add
                    (
                      Const
                        i
                      Const
                        j
                    )
                  Const
                    +
                    (
                        i
                        j
                    )
                )
                case
                (
                  Add
                    (
                      Const
                        0
                      t
                    )
                  simpl
                  (
                      t
                  )
                )
                case
                (
                  Add
                    (
                      t
                      Const
                        0
                    )
                  simpl
                  (
                      t
                  )
                )
                case
                (
                  Add
                    (
                      t1
                      t2
                    )
                  Add
                    (
                      simpl
                      (
                          t1
                      )
                      simpl
                      (
                          t2
                      )
                    )
                )
                case
                (
                  Binding
                    (
                      b
                      t
                    )
                  Binding
                    (
                      Binding.simpl
                      (
                          b
                      )
                      simpl
                      (
                          t
                      )
                    )
                )
              )
          )
        )
    "Binding"
        signature
        (
            type
            (
              t
                type
                  params =
                    (
                    )
                  cstrs =
                    (
                    )
                  kind =
                    
                         list
                        (
                            tuple
                            (
                                 string
                                (
                                )
                                 Expr.t
                                (
                                )
                            )
                        )
            )
            sig_value fv
            value_description
                arrow
                
                   t
                  (
                  )
                   StringSet.t
                  (
                  )
              (
              )
            sig_value bv
            value_description
                arrow
                
                   t
                  (
                  )
                   StringSet.t
                  (
                  )
              (
              )
            sig_value simpl
            value_description
                arrow
                
                   t
                  (
                  )
                   t
                  (
                  )
              (
              )
        )
        struct
        (
          type
          (
            t
              type
                params =
                  (
                  )
                cstrs =
                  (
                  )
                kind =
                  
                       list
                      (
                          tuple
                          (
                               string
                              (
                              )
                               Expr.t
                              (
                              )
                          )
                      )
          )
          let
          (
            fv
              (
                case
                (
                  b
                  List.fold_left
                  (
                      (
                        case
                        (
                          v
                          (
                            case
                            (
                              (
                                id
                                e
                              )
                              StringSet.union
                              (
                                  v
                                  Expr.fv
                                  (
                                      e
                                  )
                              )
                            )
                          )
                        )
                      )
                      StringSet.empty
                      b
                  )
                )
              )
          )
          let
          (
            bv
              (
                case
                (
                  b
                  List.fold_left
                  (
                      (
                        case
                        (
                          v
                          (
                            case
                            (
                              (
                                id
                                e
                              )
                              StringSet.add
                              (
                                  id
                                  v
                              )
                            )
                          )
                        )
                      )
                      StringSet.empty
                      b
                  )
                )
              )
          )
          let
          (
            simpl
              (
                case
                (
                  b
                  List.map
                  (
                      (
                        case
                        (
                          (
                            id
                            e
                          )
                          (
                            id
                            Expr.simpl
                            (
                                e
                            )
                          )
                        )
                      )
                      b
                  )
                )
              )
          )
        )
  )
  let
  (
    (
      e
        Expr.make_let
        (
            "x"
            Expr.Add
              (
                Expr.Var
                  "y"
                Expr.Const
                  0
              )
            Expr.Var
              "x"
        )
    )
  in
    let
    (
      (
        e'
          Expr.make_let
          (
              "x"
              Expr.Var
                "y"
              Expr.Var
                "x"
          )
      )
    in
      sequence
      (
        test
        (
            50
            StringSet.elements
            (
                Expr.fv
                (
                    e
                )
            )
            ::
              (
                "y"
                []
                              )
        )
      ;
        test
        (
            51
            Expr.simpl
            (
                e
            )
            e'
        )
      )
    )
  )
  module type ORDERED
    signature
    (
        type
        (
          t
            type
              params =
                (
                )
              cstrs =
                (
                )
              kind =
                
                        )
        sig_value eq
        value_description
            arrow
            
               t
              (
              )
              arrow
              
                 t
                (
                )
                 bool
                (
                )
          (
          )
        sig_value lt
        value_description
            arrow
            
               t
              (
              )
              arrow
              
                 t
                (
                )
                 bool
                (
                )
          (
          )
        sig_value leq
        value_description
            arrow
            
               t
              (
              )
              arrow
              
                 t
                (
                )
                 bool
                (
                )
          (
          )
    )
  module type HEAP
    signature
    (
        module Elem
          ORDERED
        type
        (
          heap
            type
              params =
                (
                )
              cstrs =
                (
                )
              kind =
                
                        )
        sig_value empty
        value_description
             heap
            (
            )
          (
          )
        sig_value isEmpty
        value_description
            arrow
            
               heap
              (
              )
               bool
              (
              )
          (
          )
        sig_value insert
        value_description
            arrow
            
               Elem.t
              (
              )
              arrow
              
                 heap
                (
                )
                 heap
                (
                )
          (
          )
        sig_value merge
        value_description
            arrow
            
               heap
              (
              )
              arrow
              
                 heap
                (
                )
                 heap
                (
                )
          (
          )
        sig_value findMin
        value_description
            arrow
            
               heap
              (
              )
               Elem.t
              (
              )
          (
          )
        sig_value deleteMin
        value_description
            arrow
            
               heap
              (
              )
               heap
              (
              )
          (
          )
    )
  module Bootstrap
    functor MakeH
    (
      functor Element
      (
        ORDERED
        Pmty_with
          HEAP
        (
          Elem
            Pwith_module Element
        )
      )
      functor Element
      (
        ORDERED
          struct
          (
            module Elem
              Element
            Pstr_recmodule
            (
              "BE"
                  signature
                  (
                      type
                      (
                        t
                          type
                            params =
                              (
                              )
                            cstrs =
                              (
                              )
                            kind =
                                (
                                  E
                                    (
                                    )
                                                                      H
                                    (
                                         Elem.t
                                        (
                                        )
                                         PrimH.heap
                                        (
                                        )
                                    )
                                                                    )
                                                    )
                      sig_value eq
                      value_description
                          arrow
                          
                             t
                            (
                            )
                            arrow
                            
                               t
                              (
                              )
                               bool
                              (
                              )
                        (
                        )
                      sig_value lt
                      value_description
                          arrow
                          
                             t
                            (
                            )
                            arrow
                            
                               t
                              (
                              )
                               bool
                              (
                              )
                        (
                        )
                      sig_value leq
                      value_description
                          arrow
                          
                             t
                            (
                            )
                            arrow
                            
                               t
                              (
                              )
                               bool
                              (
                              )
                        (
                        )
                  )
                  struct
                  (
                    type
                    (
                      t
                        type
                          params =
                            (
                            )
                          cstrs =
                            (
                            )
                          kind =
                              (
                                E
                                  (
                                  )
                                                                  H
                                  (
                                       Elem.t
                                      (
                                      )
                                       PrimH.heap
                                      (
                                      )
                                  )
                                                                )
                                                )
                    let
                    (
                      leq
                        (
                          case
                          (
                            t1
                            (
                              case
                              (
                                t2
                                match
                                (
                                  t1
                                  t2
                                )
                                (
                                  case
                                  (
                                    (
                                      H
                                        (
                                          x
                                          _
                                        )
                                      H
                                        (
                                          y
                                          _
                                        )
                                    )
                                    Elem.leq
                                    (
                                        x
                                        y
                                    )
                                  )
                                  case
                                  (
                                    (
                                      H
                                        _
                                      E
                                                                          )
                                    false
                                                                      )
                                  case
                                  (
                                    (
                                      E
                                                                            H
                                        _
                                    )
                                    true
                                                                      )
                                  case
                                  (
                                    (
                                      E
                                                                            E
                                                                          )
                                    true
                                                                      )
                                )
                              )
                            )
                          )
                        )
                    )
                    let
                    (
                      eq
                        (
                          case
                          (
                            t1
                            (
                              case
                              (
                                t2
                                match
                                (
                                  t1
                                  t2
                                )
                                (
                                  case
                                  (
                                    (
                                      H
                                        (
                                          x
                                          _
                                        )
                                      H
                                        (
                                          y
                                          _
                                        )
                                    )
                                    Elem.eq
                                    (
                                        x
                                        y
                                    )
                                  )
                                  case
                                  (
                                    (
                                      H
                                        _
                                      E
                                                                          )
                                    false
                                                                      )
                                  case
                                  (
                                    (
                                      E
                                                                            H
                                        _
                                    )
                                    false
                                                                      )
                                  case
                                  (
                                    (
                                      E
                                                                            E
                                                                          )
                                    true
                                                                      )
                                )
                              )
                            )
                          )
                        )
                    )
                    let
                    (
                      lt
                        (
                          case
                          (
                            t1
                            (
                              case
                              (
                                t2
                                match
                                (
                                  t1
                                  t2
                                )
                                (
                                  case
                                  (
                                    (
                                      H
                                        (
                                          x
                                          _
                                        )
                                      H
                                        (
                                          y
                                          _
                                        )
                                    )
                                    Elem.lt
                                    (
                                        x
                                        y
                                    )
                                  )
                                  case
                                  (
                                    (
                                      H
                                        _
                                      E
                                                                          )
                                    false
                                                                      )
                                  case
                                  (
                                    (
                                      E
                                                                            H
                                        _
                                    )
                                    true
                                                                      )
                                  case
                                  (
                                    (
                                      E
                                                                            E
                                                                          )
                                    false
                                                                      )
                                )
                              )
                            )
                          )
                        )
                    )
                  )
              "PrimH"
                  Pmty_with
                    HEAP
                  (
                    Elem.t
                      Pwith_type
                        type
                          params =
                            (
                            )
                          cstrs =
                            (
                            )
                          kind =
                            
                                 BE.t
                                (
                                )
                  )
                    MakeH
                  (
                    BE
                  )
            )
            type
            (
              heap
                type
                  params =
                    (
                    )
                  cstrs =
                    (
                    )
                  kind =
                    
                         BE.t
                        (
                        )
            )
            let
            (
              empty
                BE.E
                            )
            let
            (
              isEmpty
                (
                  case
                  (
                    BE.E
                                        true
                                      )
                  case
                  (
                    _
                    false
                                      )
                )
            )
            let
            (
              merge
                (
                  case
                  (
                    x
                    (
                      case
                      (
                        y
                        match
                        (
                          x
                          y
                        )
                        (
                          case
                          (
                            (
                              BE.E
                                                            _
                            )
                            y
                          )
                          case
                          (
                            (
                              _
                              BE.E
                                                          )
                            x
                          )
                          case
                          (
                            (
                              Ppat_alias "h1"
                              BE.H
                                (
                                  e1
                                  p1
                                )
                              Ppat_alias "h2"
                              BE.H
                                (
                                  e2
                                  p2
                                )
                            )
                            ifthenelse
                            (
                              if
                              (
                                Elem.leq
                                (
                                    e1
                                    e2
                                )
                              )
                              then
                              (
                                BE.H
                                  (
                                    e1
                                    PrimH.insert
                                    (
                                        h2
                                        p1
                                    )
                                  )
                              )
                              else
                              (
                                  BE.H
                                    (
                                      e2
                                      PrimH.insert
                                      (
                                          h1
                                          p2
                                      )
                                    )
                              )
                            )
                          )
                        )
                      )
                    )
                  )
                )
            )
            let
            (
              insert
                (
                  case
                  (
                    x
                    (
                      case
                      (
                        h
                        merge
                        (
                            BE.H
                              (
                                x
                                PrimH.empty
                              )
                            h
                        )
                      )
                    )
                  )
                )
            )
            let
            (
              findMin
                (
                  case
                  (
                    BE.E
                                        raise
                    (
                        Not_found
                                            )
                  )
                  case
                  (
                    BE.H
                      (
                        x
                        _
                      )
                    x
                  )
                )
            )
            let
            (
              deleteMin
                (
                  case
                  (
                    BE.E
                                        raise
                    (
                        Not_found
                                            )
                  )
                  case
                  (
                    BE.H
                      (
                        x
                        p
                      )
                    ifthenelse
                    (
                      if
                      (
                        PrimH.isEmpty
                        (
                            p
                        )
                      )
                      then
                      (
                        BE.E
                                              )
                      else
                      (
                          match
                          PrimH.findMin
                          (
                              p
                          )
                          (
                            case
                            (
                              BE.H
                                (
                                  y
                                  p1
                                )
                              let
                              (
                                (
                                  p2
                                    PrimH.deleteMin
                                    (
                                        p
                                    )
                                )
                              in
                                BE.H
                                  (
                                    y
                                    PrimH.merge
                                    (
                                        p1
                                        p2
                                    )
                                  )
                              )
                            )
                            case
                            (
                              BE.E
                                                            assert false
                            )
                          )
                      )
                    )
                  )
                )
            )
          )
          Pmty_with
            HEAP
          (
            Elem
              Pwith_module Element
          )
      )
    )
  module LeftistHeap
    functor Element
    (
      ORDERED
        struct
        (
          module Elem
            Element
          type
          (
            heap
              type
                params =
                  (
                  )
                cstrs =
                  (
                  )
                kind =
                    (
                      E
                        (
                        )
                                              T
                        (
                             int
                            (
                            )
                             Elem.t
                            (
                            )
                             heap
                            (
                            )
                             heap
                            (
                            )
                        )
                                            )
                            )
          let
          (
            rank
              (
                case
                (
                  E
                                    0
                )
                case
                (
                  T
                    (
                      r
                      _
                      _
                      _
                    )
                  r
                )
              )
          )
          let
          (
            make
              (
                case
                (
                  x
                  (
                    case
                    (
                      a
                      (
                        case
                        (
                          b
                          ifthenelse
                          (
                            if
                            (
                              >=
                              (
                                  rank
                                  (
                                      a
                                  )
                                  rank
                                  (
                                      b
                                  )
                              )
                            )
                            then
                            (
                              T
                                (
                                  +
                                  (
                                      rank
                                      (
                                          b
                                      )
                                      1
                                  )
                                  x
                                  a
                                  b
                                )
                            )
                            else
                            (
                                T
                                  (
                                    +
                                    (
                                        rank
                                        (
                                            a
                                        )
                                        1
                                    )
                                    x
                                    b
                                    a
                                  )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
          )
          let
          (
            empty
              E
                        )
          let
          (
            isEmpty
              (
                case
                (
                  E
                                    true
                                  )
                case
                (
                  _
                  false
                                  )
              )
          )
          let
          (
            merge
              (
                case
                (
                  h1
                  (
                    case
                    (
                      h2
                      match
                      (
                        h1
                        h2
                      )
                      (
                        case
                        (
                          (
                            _
                            E
                                                      )
                          h1
                        )
                        case
                        (
                          (
                            E
                                                        _
                          )
                          h2
                        )
                        case
                        (
                          (
                            T
                              (
                                _
                                x1
                                a1
                                b1
                              )
                            T
                              (
                                _
                                x2
                                a2
                                b2
                              )
                          )
                          ifthenelse
                          (
                            if
                            (
                              Elem.leq
                              (
                                  x1
                                  x2
                              )
                            )
                            then
                            (
                              make
                              (
                                  x1
                                  a1
                                  merge
                                  (
                                      b1
                                      h2
                                  )
                              )
                            )
                            else
                            (
                                make
                                (
                                    x2
                                    a2
                                    merge
                                    (
                                        h1
                                        b2
                                    )
                                )
                            )
                          )
                        )
                      )
                    )
                  )
                )
              )
          )
          let
          (
            insert
              (
                case
                (
                  x
                  (
                    case
                    (
                      h
                      merge
                      (
                          T
                            (
                              1
                              x
                              E
                                                            E
                                                          )
                          h
                      )
                    )
                  )
                )
              )
          )
          let
          (
            findMin
              (
                case
                (
                  E
                                    raise
                  (
                      Not_found
                                        )
                )
                case
                (
                  T
                    (
                      _
                      x
                      _
                      _
                    )
                  x
                )
              )
          )
          let
          (
            deleteMin
              (
                case
                (
                  E
                                    raise
                  (
                      Not_found
                                        )
                )
                case
                (
                  T
                    (
                      _
                      x
                      a
                      b
                    )
                  merge
                  (
                      a
                      b
                  )
                )
              )
          )
        )
        Pmty_with
          HEAP
        (
          Elem
            Pwith_module Element
        )
    )
  module Ints
    struct
    (
      type
      (
        t
          type
            params =
              (
              )
            cstrs =
              (
              )
            kind =
              
                   int
                  (
                  )
      )
      let
      (
        eq
          =
      )
      let
      (
        lt
          <
      )
      let
      (
        leq
          <=
      )
    )
  module C
        Bootstrap
      (
        LeftistHeap
      )
    (
      Ints
    )
  let
  (
    (
      h
        List.fold_right
        (
            C.insert
            ::
              (
                6
                ::
                  (
                    4
                    ::
                      (
                        8
                        ::
                          (
                            7
                            ::
                              (
                                3
                                ::
                                  (
                                    1
                                    []
                                                                      )
                              )
                          )
                      )
                  )
              )
            C.empty
        )
    )
  in
    sequence
    (
      test
      (
          60
          C.findMin
          (
              h
          )
          1
      )
    ;
      sequence
      (
        test
        (
            61
            C.findMin
            (
                C.deleteMin
                (
                    h
                )
            )
            3
        )
      ;
        test
        (
            62
            C.findMin
            (
                C.deleteMin
                (
                    C.deleteMin
                    (
                        h
                    )
                )
            )
            4
        )
      )
    )
  )
  Pstr_recmodule
  (
    "Class1"
        signature
        (
            sig_class
            (
              class_description ([376,9186+12]..[376,9186+48])
                pci_virt = Concrete
                pci_params =
                    (
                    )
                pci_name = "c"
                pci_expr =
                  class_type ([376,9186+16]..[376,9186+48])
                    Pcty_signature
                    class_signature
                        Ptyp_any
                      (
                        Pctf_meth "m" Public ([376,9186+23]..[376,9186+44])
                            poly
                            
                              arrow
                              
                                 int
                                (
                                )
                                 int
                                (
                                )
                      )
            )
        )
        struct
        (
          class
          (
              params =
                  (
                  )
              class name = c
              class expr =
                  class_structure
                    (
                      method m
                        (
                          case
                          (
                            x
                            ifthenelse
                            (
                              if
                              (
                                <=
                                (
                                    x
                                    0
                                )
                              )
                              then
                              (
                                x
                              )
                              else
                              (
                                  send m
                                  (
                                    new Class2.d
                                  )
                                  (
                                      x
                                  )
                              )
                            )
                          )
                        )
                                            )
          )
        )
    "Class2"
        signature
        (
            sig_class
            (
              class_description ([386,9388+12]..[386,9388+48])
                pci_virt = Concrete
                pci_params =
                    (
                    )
                pci_name = "d"
                pci_expr =
                  class_type ([386,9388+16]..[386,9388+48])
                    Pcty_signature
                    class_signature
                        Ptyp_any
                      (
                        Pctf_meth "m" Public ([386,9388+23]..[386,9388+44])
                            poly
                            
                              arrow
                              
                                 int
                                (
                                )
                                 int
                                (
                                )
                      )
            )
        )
        struct
        (
          class
          (
              params =
                  (
                  )
              class name = d
              class expr =
                  class_structure
                    (
                      Pcf_inher Fresh
                          constr Class1.c
                          (
                          )
                          "super"
                      method m
                        (
                          case
                          (
                            x
                               int
                              (
                              )
                            send m
                            (
                              super
                            )
                            (
                                0
                            )
                          )
                        )
                                            )
          )
        )
  )
  test
  (
      70
      send m
      (
        new Class1.c
      )
      (
          7
      )
      0
  )
  try
  let module A
  (
    struct
    (
      Pstr_recmodule
      (
        "BadClass1"
            signature
            (
                sig_class
                (
                  class_description ([406,9720+19]..[406,9720+48])
                    pci_virt = Concrete
                    pci_params =
                        (
                        )
                    pci_name = "c"
                    pci_expr =
                      class_type ([406,9720+23]..[406,9720+48])
                        Pcty_signature
                        class_signature
                            Ptyp_any
                          (
                            Pctf_meth "m" Public ([406,9720+30]..[406,9720+44])
                                poly
                                
                                   int
                                  (
                                  )
                          )
                )
            )
            struct
            (
              class
              (
                  params =
                      (
                      )
                  class name = c
                  class expr =
                      class_structure
                        (
                          method m
                            123
                                                    )
              )
            )
        "BadClass2"
            signature
            (
                sig_value x
                value_description
                     int
                    (
                    )
                  (
                  )
            )
            struct
            (
              let
              (
                x
                  send m
                  (
                    new BadClass1.c
                  )
              )
            )
      )
    )
  )
  in
  (
  test
  (
      71
      true
            false
        )
  )
  (
    case
    (
      Undefined_recursive_module
        _
      test
      (
          71
          true
                    true
                )
    )
  )
  Pstr_recmodule
  (
    "Coerce1"
        signature
        (
            sig_value g
            value_description
                arrow
                
                   int
                  (
                  )
                   int
                  (
                  )
              (
              )
            sig_value f
            value_description
                arrow
                
                   int
                  (
                  )
                   int
                  (
                  )
              (
              )
        )
        struct
        (
          module A
              Coerce1
              signature
              (
                  sig_value f
                  value_description
                      arrow
                      
                         int
                        (
                        )
                         int
                        (
                        )
                    (
                    )
              )
          let
          (
            g
              (
                case
                (
                  x
                  x
                )
              )
          )
          let
          (
            f
              (
                case
                (
                  x
                  ifthenelse
                  (
                    if
                    (
                      <=
                      (
                          x
                          0
                      )
                    )
                    then
                    (
                      1
                    )
                    else
                    (
                        *
                        (
                            A.f
                            (
                                -
                                (
                                    x
                                    1
                                )
                            )
                            x
                        )
                    )
                  )
                )
              )
          )
        )
  )
  test
  (
      80
      Coerce1.f
      (
          10
      )
      3628800
  )
  module CoerceF
    functor S
    (
      signature
      (
      )
      struct
      (
        let
        (
          f1
            (
              case
              (
                ()
                                1
              )
            )
        )
        let
        (
          f2
            (
              case
              (
                ()
                                2
              )
            )
        )
        let
        (
          f3
            (
              case
              (
                ()
                                3
              )
            )
        )
        let
        (
          f4
            (
              case
              (
                ()
                                4
              )
            )
        )
        let
        (
          f5
            (
              case
              (
                ()
                                5
              )
            )
        )
      )
    )
  Pstr_recmodule
  (
    "Coerce2"
        signature
        (
            sig_value f1
            value_description
                arrow
                
                   unit
                  (
                  )
                   int
                  (
                  )
              (
              )
        )
          CoerceF
        (
          Coerce3
        )
    "Coerce3"
        signature
        (
        )
        struct
        (
        )
  )
  test
  (
      81
      Coerce2.f1
      (
          ()
                )
      1
  )
  module Coerce4
    functor A
    (
      signature
      (
          sig_value f
          value_description
              arrow
              
                 int
                (
                )
                 int
                (
                )
            (
            )
      )
      struct
      (
        let
        (
          x
            0
        )
        let
        (
          at
            (
              case
              (
                a
                A.f
                (
                    a
                )
              )
            )
        )
      )
    )
  Pstr_recmodule
  (
    "Coerce5"
        signature
        (
            sig_value blabla
            value_description
                arrow
                
                   int
                  (
                  )
                   int
                  (
                  )
              (
              )
            sig_value f
            value_description
                arrow
                
                   int
                  (
                  )
                   int
                  (
                  )
              (
              )
        )
        struct
        (
          let
          (
            blabla
              (
                case
                (
                  x
                  0
                )
              )
          )
          let
          (
            f
              (
                case
                (
                  x
                  5
                )
              )
          )
        )
    "Coerce6"
        signature
        (
            sig_value at
            value_description
                arrow
                
                   int
                  (
                  )
                   int
                  (
                  )
              (
              )
        )
          Coerce4
        (
          Coerce5
        )
  )
  test
  (
      82
      Coerce6.at
      (
          100
      )
      5
  )
  Pstr_recmodule
  (
    "F"
        signature
        (
            type
            (
              t
                type
                  params =
                    (
                    )
                  cstrs =
                    (
                    )
                  kind =
                      (
                        X
                          (
                               int
                              (
                              )
                          )
                                                  Y
                          (
                               int
                              (
                              )
                          )
                                                )
                                )
            sig_value f
            value_description
                arrow
                
                   t
                  (
                  )
                   bool
                  (
                  )
              (
              )
        )
        struct
        (
          type
          (
            t
              type
                params =
                  (
                  )
                cstrs =
                  (
                  )
                kind =
                    (
                      X
                        (
                             int
                            (
                            )
                        )
                                              Y
                        (
                             int
                            (
                            )
                        )
                                            )
                            )
          let
          (
            f
              (
                case
                (
                  X
                    _
                  false
                                  )
                case
                (
                  _
                  true
                                  )
              )
          )
        )
  )
  sequence
  (
    test
    (
        100
        F.f
        (
            F.X
              1
        )
        false
            )
  ;
    test
    (
        101
        F.f
        (
            F.Y
              2
        )
        true
            )
  )
  module G
    functor S
    (
      signature
      (
          sig_value x
          value_description
               Lazy.t
              (
                   int
                  (
                  )
              )
            (
            )
      )
      struct
      (
        include
        (
          S
        )
      )
    )
  module M1
    struct
    (
      let
      (
        x
          Pexp_lazy          3
      )
    )
  Lazy.force
  (
      M1.x
  )
  Pstr_recmodule
  (
    "M2"
        signature
        (
            sig_value x
            value_description
                 Lazy.t
                (
                     int
                    (
                    )
                )
              (
              )
        )
          G
        (
          M1
        )
  )
  test
  (
      102
      Lazy.force
      (
          M2.x
      )
      3
  )
  Gc.full_major
  (
      ()
        )
  Pstr_recmodule
  (
    "M3"
        signature
        (
            sig_value x
            value_description
                 Lazy.t
                (
                     int
                    (
                    )
                )
              (
              )
        )
          G
        (
          M1
        )
  )
  test
  (
      103
      Lazy.force
      (
          M3.x
      )
      3
  )
)

